
build/netvcr.elf:     file format elf32-littlearm


Disassembly of section .text:

00000420 <Reset_Handler>:
     420:	b672      	cpsid	i
     422:	4822      	ldr	r0, [pc, #136]	; (4ac <endfiniloop+0x4>)
     424:	f380 8809 	msr	PSP, r0
     428:	2002      	movs	r0, #2
     42a:	f380 8814 	msr	CONTROL, r0
     42e:	f3bf 8f6f 	isb	sy
     432:	f000 f875 	bl	520 <__core_init>
     436:	f001 fa0b 	bl	1850 <__early_init>
     43a:	481d      	ldr	r0, [pc, #116]	; (4b0 <endfiniloop+0x8>)
     43c:	491d      	ldr	r1, [pc, #116]	; (4b4 <endfiniloop+0xc>)
     43e:	4a1e      	ldr	r2, [pc, #120]	; (4b8 <endfiniloop+0x10>)

00000440 <msloop>:
     440:	4291      	cmp	r1, r2
     442:	bf3c      	itt	cc
     444:	f841 0b04 	strcc.w	r0, [r1], #4
     448:	e7fa      	bcc.n	440 <msloop>
     44a:	491c      	ldr	r1, [pc, #112]	; (4bc <endfiniloop+0x14>)
     44c:	4a17      	ldr	r2, [pc, #92]	; (4ac <endfiniloop+0x4>)

0000044e <psloop>:
     44e:	4291      	cmp	r1, r2
     450:	bf3c      	itt	cc
     452:	f841 0b04 	strcc.w	r0, [r1], #4
     456:	e7fa      	bcc.n	44e <psloop>
     458:	4919      	ldr	r1, [pc, #100]	; (4c0 <endfiniloop+0x18>)
     45a:	4a1a      	ldr	r2, [pc, #104]	; (4c4 <endfiniloop+0x1c>)
     45c:	4b1a      	ldr	r3, [pc, #104]	; (4c8 <endfiniloop+0x20>)

0000045e <dloop>:
     45e:	429a      	cmp	r2, r3
     460:	bf3e      	ittt	cc
     462:	f851 0b04 	ldrcc.w	r0, [r1], #4
     466:	f842 0b04 	strcc.w	r0, [r2], #4
     46a:	e7f8      	bcc.n	45e <dloop>
     46c:	2000      	movs	r0, #0
     46e:	4917      	ldr	r1, [pc, #92]	; (4cc <endfiniloop+0x24>)
     470:	4a17      	ldr	r2, [pc, #92]	; (4d0 <endfiniloop+0x28>)

00000472 <bloop>:
     472:	4291      	cmp	r1, r2
     474:	bf3c      	itt	cc
     476:	f841 0b04 	strcc.w	r0, [r1], #4
     47a:	e7fa      	bcc.n	472 <bloop>
     47c:	f000 f868 	bl	550 <__init_ram_areas>
     480:	f000 f856 	bl	530 <__late_init>
     484:	4c13      	ldr	r4, [pc, #76]	; (4d4 <endfiniloop+0x2c>)
     486:	4d14      	ldr	r5, [pc, #80]	; (4d8 <endfiniloop+0x30>)

00000488 <initloop>:
     488:	42ac      	cmp	r4, r5
     48a:	da03      	bge.n	494 <endinitloop>
     48c:	f854 1b04 	ldr.w	r1, [r4], #4
     490:	4788      	blx	r1
     492:	e7f9      	b.n	488 <initloop>

00000494 <endinitloop>:
     494:	f001 f9f4 	bl	1880 <main>
     498:	4c10      	ldr	r4, [pc, #64]	; (4dc <endfiniloop+0x34>)
     49a:	4d11      	ldr	r5, [pc, #68]	; (4e0 <endfiniloop+0x38>)

0000049c <finiloop>:
     49c:	42ac      	cmp	r4, r5
     49e:	da03      	bge.n	4a8 <endfiniloop>
     4a0:	f854 1b04 	ldr.w	r1, [r4], #4
     4a4:	4788      	blx	r1
     4a6:	e7f9      	b.n	49c <finiloop>

000004a8 <endfiniloop>:
     4a8:	f000 b84a 	b.w	540 <__default_exit>
     4ac:	1fffe600 	.word	0x1fffe600
     4b0:	55555555 	.word	0x55555555
     4b4:	1fffe000 	.word	0x1fffe000
     4b8:	1fffe400 	.word	0x1fffe400
     4bc:	1fffe400 	.word	0x1fffe400
     4c0:	00002188 	.word	0x00002188
     4c4:	1fffe600 	.word	0x1fffe600
     4c8:	1fffe604 	.word	0x1fffe604
     4cc:	1fffe608 	.word	0x1fffe608
     4d0:	1fffe850 	.word	0x1fffe850
     4d4:	00000410 	.word	0x00000410
     4d8:	00000410 	.word	0x00000410
     4dc:	00000410 	.word	0x00000410
     4e0:	00000410 	.word	0x00000410
	...

000004f0 <_port_switch>:
     4f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     4f4:	f8c1 d00c 	str.w	sp, [r1, #12]
     4f8:	68c3      	ldr	r3, [r0, #12]
     4fa:	469d      	mov	sp, r3
     4fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00000500 <_port_thread_start>:
     500:	2300      	movs	r3, #0
     502:	f383 8811 	msr	BASEPRI, r3
     506:	4628      	mov	r0, r5
     508:	47a0      	blx	r4
     50a:	2000      	movs	r0, #0
     50c:	f000 fae8 	bl	ae0 <chThdExit>

00000510 <_port_switch_from_isr>:
     510:	f000 fa3e 	bl	990 <chSchDoReschedule>

00000514 <_port_exit_from_isr>:
     514:	df00      	svc	0
     516:	e7fe      	b.n	516 <_port_exit_from_isr+0x2>
	...

00000520 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
     520:	4770      	bx	lr
     522:	bf00      	nop
     524:	f3af 8000 	nop.w
     528:	f3af 8000 	nop.w
     52c:	f3af 8000 	nop.w

00000530 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
     530:	4770      	bx	lr
     532:	bf00      	nop
     534:	f3af 8000 	nop.w
     538:	f3af 8000 	nop.w
     53c:	f3af 8000 	nop.w

00000540 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
     540:	e7fe      	b.n	540 <__default_exit>
     542:	bf00      	nop
     544:	f3af 8000 	nop.w
     548:	f3af 8000 	nop.w
     54c:	f3af 8000 	nop.w

00000550 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
     550:	b4f0      	push	{r4, r5, r6, r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
     552:	4e11      	ldr	r6, [pc, #68]	; (598 <__init_ram_areas+0x48>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
     554:	2500      	movs	r5, #0
     556:	f106 0780 	add.w	r7, r6, #128	; 0x80
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
     55a:	e896 001a 	ldmia.w	r6, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
     55e:	42a3      	cmp	r3, r4
     560:	d20d      	bcs.n	57e <__init_ram_areas+0x2e>
     562:	3904      	subs	r1, #4
     564:	461a      	mov	r2, r3
      *p = *tp;
     566:	f851 0f04 	ldr.w	r0, [r1, #4]!
     56a:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
     56e:	42a2      	cmp	r2, r4
     570:	d3f9      	bcc.n	566 <__init_ram_areas+0x16>
     572:	43da      	mvns	r2, r3
     574:	4414      	add	r4, r2
     576:	f024 0403 	bic.w	r4, r4, #3
     57a:	3404      	adds	r4, #4
     57c:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
     57e:	68f2      	ldr	r2, [r6, #12]
     580:	4293      	cmp	r3, r2
     582:	d203      	bcs.n	58c <__init_ram_areas+0x3c>
      *p = 0;
     584:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
     588:	4293      	cmp	r3, r2
     58a:	d3fb      	bcc.n	584 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
     58c:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
     58e:	42be      	cmp	r6, r7
     590:	d3e3      	bcc.n	55a <__init_ram_areas+0xa>
#endif
}
     592:	bcf0      	pop	{r4, r5, r6, r7}
     594:	4770      	bx	lr
     596:	bf00      	nop
     598:	00001d60 	.word	0x00001d60
     59c:	f3af 8000 	nop.w

000005a0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
     5a0:	e7fe      	b.n	5a0 <_unhandled_exception>
     5a2:	bf00      	nop
     5a4:	f3af 8000 	nop.w
     5a8:	f3af 8000 	nop.w
     5ac:	f3af 8000 	nop.w

000005b0 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
     5b0:	e7fe      	b.n	5b0 <_idle_thread>
     5b2:	bf00      	nop
     5b4:	f3af 8000 	nop.w
     5b8:	f3af 8000 	nop.w
     5bc:	f3af 8000 	nop.w

000005c0 <chSysInit>:
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
     5c0:	4b1e      	ldr	r3, [pc, #120]	; (63c <chSysInit+0x7c>)
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
     5c2:	4a1f      	ldr	r2, [pc, #124]	; (640 <chSysInit+0x80>)
  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
     5c4:	481f      	ldr	r0, [pc, #124]	; (644 <chSysInit+0x84>)
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
     5c6:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
     5c8:	2400      	movs	r4, #0
     5ca:	609c      	str	r4, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
     5cc:	68df      	ldr	r7, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
     5ce:	4e1e      	ldr	r6, [pc, #120]	; (648 <chSysInit+0x88>)
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
     5d0:	4d1e      	ldr	r5, [pc, #120]	; (64c <chSysInit+0x8c>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
     5d2:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
     5d6:	4039      	ands	r1, r7
  reg_value  =  (reg_value                                   |
     5d8:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
     5da:	60da      	str	r2, [r3, #12]
     5dc:	68f2      	ldr	r2, [r6, #12]
     5de:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
     5e2:	60f2      	str	r2, [r6, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
     5e4:	6802      	ldr	r2, [r0, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     5e6:	2120      	movs	r1, #32
     5e8:	f042 0201 	orr.w	r2, r2, #1
     5ec:	2610      	movs	r6, #16
     5ee:	6002      	str	r2, [r0, #0]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
     5f0:	b083      	sub	sp, #12
     5f2:	77de      	strb	r6, [r3, #31]
     5f4:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
     5f8:	f000 f8da 	bl	7b0 <_scheduler_init>
  _vt_init();
     5fc:	f000 f858 	bl	6b0 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
     600:	f000 fc16 	bl	e30 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
     604:	f000 fc5c 	bl	ec0 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
     608:	4628      	mov	r0, r5
     60a:	2140      	movs	r1, #64	; 0x40
     60c:	f000 f9d0 	bl	9b0 <_thread_init>
     610:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
     614:	2201      	movs	r2, #1
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
     616:	6198      	str	r0, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
     618:	7702      	strb	r2, [r0, #28]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     61a:	f384 8811 	msr	BASEPRI, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
     61e:	b662      	cpsie	i
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
     620:	699b      	ldr	r3, [r3, #24]
     622:	490b      	ldr	r1, [pc, #44]	; (650 <chSysInit+0x90>)
     624:	6199      	str	r1, [r3, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
     626:	f105 0048 	add.w	r0, r5, #72	; 0x48
     62a:	9400      	str	r4, [sp, #0]
     62c:	21d8      	movs	r1, #216	; 0xd8
     62e:	4b09      	ldr	r3, [pc, #36]	; (654 <chSysInit+0x94>)
     630:	f000 f9e6 	bl	a00 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
     634:	4b08      	ldr	r3, [pc, #32]	; (658 <chSysInit+0x98>)
     636:	6183      	str	r3, [r0, #24]
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
  }
#endif
}
     638:	b003      	add	sp, #12
     63a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     63c:	e000ed00 	.word	0xe000ed00
     640:	05fa0300 	.word	0x05fa0300
     644:	e0001000 	.word	0xe0001000
     648:	e000edf0 	.word	0xe000edf0
     64c:	1fffe638 	.word	0x1fffe638
     650:	00001df0 	.word	0x00001df0
     654:	000005b1 	.word	0x000005b1
     658:	00001de0 	.word	0x00001de0
     65c:	f3af 8000 	nop.w

00000660 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     660:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chDbgCheckClassI();

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > (tslices_t)0) {
     662:	4d11      	ldr	r5, [pc, #68]	; (6a8 <chSysTimerHandlerI+0x48>)
     664:	69aa      	ldr	r2, [r5, #24]
     666:	7fd3      	ldrb	r3, [r2, #31]
     668:	b10b      	cbz	r3, 66e <chSysTimerHandlerI+0xe>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
     66a:	3b01      	subs	r3, #1
     66c:	77d3      	strb	r3, [r2, #31]
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
     66e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
     670:	69eb      	ldr	r3, [r5, #28]
     672:	4e0e      	ldr	r6, [pc, #56]	; (6ac <chSysTimerHandlerI+0x4c>)
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
     674:	3201      	adds	r2, #1
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
     676:	42b3      	cmp	r3, r6
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
     678:	62aa      	str	r2, [r5, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
     67a:	d013      	beq.n	6a4 <chSysTimerHandlerI+0x44>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
     67c:	689c      	ldr	r4, [r3, #8]
     67e:	3c01      	subs	r4, #1
     680:	609c      	str	r4, [r3, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
     682:	b97c      	cbnz	r4, 6a4 <chSysTimerHandlerI+0x44>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     684:	2720      	movs	r7, #32
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
      vtp->vt_func = NULL;
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     686:	681a      	ldr	r2, [r3, #0]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
     688:	68d9      	ldr	r1, [r3, #12]
      vtp->vt_func = NULL;
     68a:	60dc      	str	r4, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     68c:	6056      	str	r6, [r2, #4]
      ch.vtlist.vt_next = vtp->vt_next;
     68e:	61ea      	str	r2, [r5, #28]
     690:	f384 8811 	msr	BASEPRI, r4
      chSysUnlockFromISR();
      fn(vtp->vt_par);
     694:	6918      	ldr	r0, [r3, #16]
     696:	4788      	blx	r1
     698:	f387 8811 	msr	BASEPRI, r7
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
     69c:	69eb      	ldr	r3, [r5, #28]
     69e:	689a      	ldr	r2, [r3, #8]
     6a0:	2a00      	cmp	r2, #0
     6a2:	d0f0      	beq.n	686 <chSysTimerHandlerI+0x26>
     6a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     6a6:	bf00      	nop
     6a8:	1fffe608 	.word	0x1fffe608
     6ac:	1fffe624 	.word	0x1fffe624

000006b0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
     6b0:	4b05      	ldr	r3, [pc, #20]	; (6c8 <_vt_init+0x18>)
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
     6b2:	f04f 30ff 	mov.w	r0, #4294967295
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
     6b6:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
     6ba:	2100      	movs	r1, #0
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
     6bc:	6258      	str	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
     6be:	6299      	str	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
     6c0:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
     6c2:	621a      	str	r2, [r3, #32]
     6c4:	4770      	bx	lr
     6c6:	bf00      	nop
     6c8:	1fffe608 	.word	0x1fffe608
     6cc:	f3af 8000 	nop.w

000006d0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
     6d0:	b470      	push	{r4, r5, r6}
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
     6d2:	4e0d      	ldr	r6, [pc, #52]	; (708 <chVTDoSetI+0x38>)
     6d4:	69f4      	ldr	r4, [r6, #28]
  while (p->vt_delta < delta) {
     6d6:	68a5      	ldr	r5, [r4, #8]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
     6d8:	6103      	str	r3, [r0, #16]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
     6da:	42a9      	cmp	r1, r5

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
     6dc:	60c2      	str	r2, [r0, #12]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
     6de:	d904      	bls.n	6ea <chVTDoSetI+0x1a>
    delta -= p->vt_delta;
    p = p->vt_next;
     6e0:	6824      	ldr	r4, [r4, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
     6e2:	1b49      	subs	r1, r1, r5
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
     6e4:	68a5      	ldr	r5, [r4, #8]
     6e6:	428d      	cmp	r5, r1
     6e8:	d3fa      	bcc.n	6e0 <chVTDoSetI+0x10>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
     6ea:	6863      	ldr	r3, [r4, #4]
     6ec:	6043      	str	r3, [r0, #4]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
     6ee:	6004      	str	r4, [r0, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
     6f0:	6018      	str	r0, [r3, #0]
  p->vt_prev = vtp;
     6f2:	6060      	str	r0, [r4, #4]
  vtp->vt_delta = delta
     6f4:	6081      	str	r1, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
     6f6:	68a3      	ldr	r3, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
     6f8:	f04f 32ff 	mov.w	r2, #4294967295
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
     6fc:	1a59      	subs	r1, r3, r1
     6fe:	60a1      	str	r1, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
     700:	6272      	str	r2, [r6, #36]	; 0x24
}
     702:	bc70      	pop	{r4, r5, r6}
     704:	4770      	bx	lr
     706:	bf00      	nop
     708:	1fffe608 	.word	0x1fffe608
     70c:	f3af 8000 	nop.w

00000710 <chVTDoResetI>:
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
     710:	6803      	ldr	r3, [r0, #0]
     712:	6882      	ldr	r2, [r0, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
     714:	6841      	ldr	r1, [r0, #4]
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
     716:	b430      	push	{r4, r5}
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
     718:	689d      	ldr	r5, [r3, #8]
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
     71a:	4c06      	ldr	r4, [pc, #24]	; (734 <chVTDoResetI+0x24>)
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
     71c:	442a      	add	r2, r5
     71e:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
     720:	600b      	str	r3, [r1, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
     722:	6805      	ldr	r5, [r0, #0]
  vtp->vt_func = NULL;
     724:	2200      	movs	r2, #0

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
     726:	f04f 33ff 	mov.w	r3, #4294967295
  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
     72a:	6069      	str	r1, [r5, #4]
  vtp->vt_func = NULL;
     72c:	60c2      	str	r2, [r0, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
     72e:	6263      	str	r3, [r4, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     730:	bc30      	pop	{r4, r5}
     732:	4770      	bx	lr
     734:	1fffe608 	.word	0x1fffe608
     738:	f3af 8000 	nop.w
     73c:	f3af 8000 	nop.w

00000740 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
     740:	b410      	push	{r4}
     742:	2320      	movs	r3, #32
     744:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
     748:	7f03      	ldrb	r3, [r0, #28]
     74a:	2b07      	cmp	r3, #7
     74c:	d80e      	bhi.n	76c <wakeup+0x2c>
     74e:	e8df f003 	tbb	[pc, r3]
     752:	0d27      	.short	0x0d27
     754:	0408230d 	.word	0x0408230d
     758:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
     75a:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
     75c:	6893      	ldr	r3, [r2, #8]
     75e:	3301      	adds	r3, #1
     760:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
     762:	e890 000c 	ldmia.w	r0, {r2, r3}
     766:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
     768:	6802      	ldr	r2, [r0, #0]
     76a:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
     76c:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     770:	2200      	movs	r2, #0
     772:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
     774:	4b0d      	ldr	r3, [pc, #52]	; (7ac <wakeup+0x6c>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
     776:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     778:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
     77a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
     77c:	689a      	ldr	r2, [r3, #8]
     77e:	428a      	cmp	r2, r1
     780:	d2fb      	bcs.n	77a <wakeup+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
     782:	685a      	ldr	r2, [r3, #4]
     784:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     786:	6003      	str	r3, [r0, #0]
     788:	2100      	movs	r1, #0
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
     78a:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
     78c:	6058      	str	r0, [r3, #4]
     78e:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
     792:	f85d 4b04 	ldr.w	r4, [sp], #4
     796:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
     798:	6a03      	ldr	r3, [r0, #32]
     79a:	2200      	movs	r2, #0
     79c:	601a      	str	r2, [r3, #0]
    break;
     79e:	e7e5      	b.n	76c <wakeup+0x2c>
     7a0:	2300      	movs	r3, #0
     7a2:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
     7a6:	f85d 4b04 	ldr.w	r4, [sp], #4
     7aa:	4770      	bx	lr
     7ac:	1fffe608 	.word	0x1fffe608

000007b0 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
     7b0:	4b03      	ldr	r3, [pc, #12]	; (7c0 <_scheduler_init+0x10>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
     7b2:	2200      	movs	r2, #0
     7b4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
     7b6:	605b      	str	r3, [r3, #4]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
     7b8:	611b      	str	r3, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
     7ba:	615b      	str	r3, [r3, #20]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
     7bc:	609a      	str	r2, [r3, #8]
     7be:	4770      	bx	lr
     7c0:	1fffe608 	.word	0x1fffe608
     7c4:	f3af 8000 	nop.w
     7c8:	f3af 8000 	nop.w
     7cc:	f3af 8000 	nop.w

000007d0 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     7d0:	2200      	movs	r2, #0
     7d2:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
     7d4:	4b08      	ldr	r3, [pc, #32]	; (7f8 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     7d6:	b410      	push	{r4}
     7d8:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     7da:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
     7dc:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
     7de:	689a      	ldr	r2, [r3, #8]
     7e0:	428a      	cmp	r2, r1
     7e2:	d2fb      	bcs.n	7dc <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
     7e4:	685a      	ldr	r2, [r3, #4]
     7e6:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     7e8:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
     7ea:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
     7ec:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
     7ee:	605c      	str	r4, [r3, #4]

  return tp;
}
     7f0:	f85d 4b04 	ldr.w	r4, [sp], #4
     7f4:	4770      	bx	lr
     7f6:	bf00      	nop
     7f8:	1fffe608 	.word	0x1fffe608
     7fc:	f3af 8000 	nop.w

00000800 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
     800:	4b08      	ldr	r3, [pc, #32]	; (824 <chSchGoSleepS+0x24>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
     802:	b430      	push	{r4, r5}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
     804:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
     806:	6999      	ldr	r1, [r3, #24]

  tqp->p_next = tp->p_next;
     808:	6814      	ldr	r4, [r2, #0]
  otp->p_state = newstate;
     80a:	7708      	strb	r0, [r1, #28]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
     80c:	2501      	movs	r5, #1
  otp = currp;
  otp->p_state = newstate;
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
     80e:	2014      	movs	r0, #20
     810:	77c8      	strb	r0, [r1, #31]
  tqp->p_next->p_prev = (thread_t *)tqp;
     812:	6063      	str	r3, [r4, #4]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
     814:	7715      	strb	r5, [r2, #28]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
     816:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
     818:	4610      	mov	r0, r2
}
     81a:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
     81c:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
     81e:	f7ff be67 	b.w	4f0 <_port_switch>
     822:	bf00      	nop
     824:	1fffe608 	.word	0x1fffe608
     828:	f3af 8000 	nop.w
     82c:	f3af 8000 	nop.w

00000830 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
     830:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
     832:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
     834:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
     836:	d012      	beq.n	85e <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
     838:	4c0c      	ldr	r4, [pc, #48]	; (86c <chSchGoSleepTimeoutS+0x3c>)
     83a:	4a0d      	ldr	r2, [pc, #52]	; (870 <chSchGoSleepTimeoutS+0x40>)
     83c:	69a3      	ldr	r3, [r4, #24]
     83e:	4605      	mov	r5, r0
     840:	a801      	add	r0, sp, #4
     842:	f7ff ff45 	bl	6d0 <chVTDoSetI>
    chSchGoSleepS(newstate);
     846:	4628      	mov	r0, r5
     848:	f7ff ffda 	bl	800 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     84c:	9b04      	ldr	r3, [sp, #16]
     84e:	b113      	cbz	r3, 856 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
     850:	a801      	add	r0, sp, #4
     852:	f7ff ff5d 	bl	710 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
     856:	69a3      	ldr	r3, [r4, #24]
}
     858:	6a18      	ldr	r0, [r3, #32]
     85a:	b007      	add	sp, #28
     85c:	bd30      	pop	{r4, r5, pc}
     85e:	4c03      	ldr	r4, [pc, #12]	; (86c <chSchGoSleepTimeoutS+0x3c>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
     860:	f7ff ffce 	bl	800 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
     864:	69a3      	ldr	r3, [r4, #24]
}
     866:	6a18      	ldr	r0, [r3, #32]
     868:	b007      	add	sp, #28
     86a:	bd30      	pop	{r4, r5, pc}
     86c:	1fffe608 	.word	0x1fffe608
     870:	00000741 	.word	0x00000741
     874:	f3af 8000 	nop.w
     878:	f3af 8000 	nop.w
     87c:	f3af 8000 	nop.w

00000880 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
     880:	4b14      	ldr	r3, [pc, #80]	; (8d4 <chSchWakeupS+0x54>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     882:	b4f0      	push	{r4, r5, r6, r7}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
     884:	699f      	ldr	r7, [r3, #24]
     886:	6884      	ldr	r4, [r0, #8]
     888:	68bd      	ldr	r5, [r7, #8]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
     88a:	6201      	str	r1, [r0, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
     88c:	42ac      	cmp	r4, r5
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     88e:	4606      	mov	r6, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     890:	f04f 0200 	mov.w	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
     894:	d80b      	bhi.n	8ae <chSchWakeupS+0x2e>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     896:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
     898:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
     89a:	689a      	ldr	r2, [r3, #8]
     89c:	4294      	cmp	r4, r2
     89e:	d9fb      	bls.n	898 <chSchWakeupS+0x18>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
     8a0:	685a      	ldr	r2, [r3, #4]
     8a2:	6072      	str	r2, [r6, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     8a4:	6033      	str	r3, [r6, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
     8a6:	6016      	str	r6, [r2, #0]
  cp->p_prev = tp;
     8a8:	605e      	str	r6, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
     8aa:	bcf0      	pop	{r4, r5, r6, r7}
     8ac:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     8ae:	773a      	strb	r2, [r7, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
     8b0:	461a      	mov	r2, r3
  do {
    cp = cp->p_next;
     8b2:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
     8b4:	6894      	ldr	r4, [r2, #8]
     8b6:	42a5      	cmp	r5, r4
     8b8:	d9fb      	bls.n	8b2 <chSchWakeupS+0x32>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
     8ba:	6850      	ldr	r0, [r2, #4]
     8bc:	6078      	str	r0, [r7, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
     8be:	2401      	movs	r4, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     8c0:	603a      	str	r2, [r7, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
     8c2:	6007      	str	r7, [r0, #0]
  cp->p_prev = tp;
     8c4:	6057      	str	r7, [r2, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
     8c6:	7734      	strb	r4, [r6, #28]
    chSysSwitch(ntp, otp);
     8c8:	4639      	mov	r1, r7
     8ca:	4630      	mov	r0, r6
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
     8cc:	619e      	str	r6, [r3, #24]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
     8ce:	bcf0      	pop	{r4, r5, r6, r7}
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
     8d0:	f7ff be0e 	b.w	4f0 <_port_switch>
     8d4:	1fffe608 	.word	0x1fffe608
     8d8:	f3af 8000 	nop.w
     8dc:	f3af 8000 	nop.w

000008e0 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
     8e0:	4b08      	ldr	r3, [pc, #32]	; (904 <chSchIsPreemptionRequired+0x24>)
  tprio_t p2 = currp->p_prio;
     8e2:	699a      	ldr	r2, [r3, #24]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
     8e4:	681b      	ldr	r3, [r3, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
     8e6:	7fd1      	ldrb	r1, [r2, #31]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
     8e8:	689b      	ldr	r3, [r3, #8]
  tprio_t p2 = currp->p_prio;
     8ea:	6890      	ldr	r0, [r2, #8]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
     8ec:	b921      	cbnz	r1, 8f8 <chSchIsPreemptionRequired+0x18>
     8ee:	4283      	cmp	r3, r0
     8f0:	bf34      	ite	cc
     8f2:	2000      	movcc	r0, #0
     8f4:	2001      	movcs	r0, #1
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
     8f6:	4770      	bx	lr
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
     8f8:	4283      	cmp	r3, r0
     8fa:	bf94      	ite	ls
     8fc:	2000      	movls	r0, #0
     8fe:	2001      	movhi	r0, #1
     900:	4770      	bx	lr
     902:	bf00      	nop
     904:	1fffe608 	.word	0x1fffe608
     908:	f3af 8000 	nop.w
     90c:	f3af 8000 	nop.w

00000910 <chSchDoRescheduleBehind>:
 * @special
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
     910:	4a0e      	ldr	r2, [pc, #56]	; (94c <chSchDoRescheduleBehind+0x3c>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
     912:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
     914:	b4f0      	push	{r4, r5, r6, r7}

  tqp->p_next = tp->p_next;
     916:	6803      	ldr	r3, [r0, #0]
  thread_t *otp;

  otp = currp;
     918:	6995      	ldr	r5, [r2, #24]
     91a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
     91c:	2701      	movs	r7, #1
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
     91e:	2614      	movs	r6, #20
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     920:	2100      	movs	r1, #0
     922:	68ac      	ldr	r4, [r5, #8]
  tqp->p_next->p_prev = (thread_t *)tqp;
     924:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
     926:	7707      	strb	r7, [r0, #28]
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
     928:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
     92a:	77ee      	strb	r6, [r5, #31]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     92c:	7729      	strb	r1, [r5, #28]
     92e:	e000      	b.n	932 <chSchDoRescheduleBehind+0x22>
     930:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
     932:	689a      	ldr	r2, [r3, #8]
     934:	42a2      	cmp	r2, r4
     936:	d2fb      	bcs.n	930 <chSchDoRescheduleBehind+0x20>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
     938:	685a      	ldr	r2, [r3, #4]
     93a:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     93c:	602b      	str	r3, [r5, #0]
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
     93e:	4629      	mov	r1, r5
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
     940:	6015      	str	r5, [r2, #0]
  cp->p_prev = tp;
     942:	605d      	str	r5, [r3, #4]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
}
     944:	bcf0      	pop	{r4, r5, r6, r7}
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
     946:	f7ff bdd3 	b.w	4f0 <_port_switch>
     94a:	bf00      	nop
     94c:	1fffe608 	.word	0x1fffe608

00000950 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
     950:	4a0d      	ldr	r2, [pc, #52]	; (988 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
     952:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
     954:	b470      	push	{r4, r5, r6}

  tqp->p_next = tp->p_next;
     956:	6803      	ldr	r3, [r0, #0]
  thread_t *otp, *cp;

  otp = currp;
     958:	6995      	ldr	r5, [r2, #24]
     95a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
     95c:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
     95e:	2100      	movs	r1, #0
     960:	68ac      	ldr	r4, [r5, #8]
  tqp->p_next->p_prev = (thread_t *)tqp;
     962:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
     964:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
     966:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
     968:	7729      	strb	r1, [r5, #28]
     96a:	e000      	b.n	96e <chSchDoRescheduleAhead+0x1e>
     96c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
     96e:	689a      	ldr	r2, [r3, #8]
     970:	42a2      	cmp	r2, r4
     972:	d8fb      	bhi.n	96c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
     974:	685a      	ldr	r2, [r3, #4]
     976:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
     978:	602b      	str	r3, [r5, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
     97a:	4629      	mov	r1, r5
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
     97c:	6015      	str	r5, [r2, #0]
  cp->p_prev = otp;
     97e:	605d      	str	r5, [r3, #4]

  chSysSwitch(currp, otp);
}
     980:	bc70      	pop	{r4, r5, r6}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
     982:	f7ff bdb5 	b.w	4f0 <_port_switch>
     986:	bf00      	nop
     988:	1fffe608 	.word	0x1fffe608
     98c:	f3af 8000 	nop.w

00000990 <chSchDoReschedule>:
void chSchDoReschedule(void) {

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
     990:	4b03      	ldr	r3, [pc, #12]	; (9a0 <chSchDoReschedule+0x10>)
     992:	699b      	ldr	r3, [r3, #24]
     994:	7fdb      	ldrb	r3, [r3, #31]
     996:	b10b      	cbz	r3, 99c <chSchDoReschedule+0xc>
    chSchDoRescheduleBehind();
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
     998:	f7ff bfda 	b.w	950 <chSchDoRescheduleAhead>
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
     99c:	f7ff bfb8 	b.w	910 <chSchDoRescheduleBehind>
     9a0:	1fffe608 	.word	0x1fffe608
     9a4:	f3af 8000 	nop.w
     9a8:	f3af 8000 	nop.w
     9ac:	f3af 8000 	nop.w

000009b0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
     9b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
     9b4:	4c10      	ldr	r4, [pc, #64]	; (9f8 <_thread_init+0x48>)
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
     9b6:	63c1      	str	r1, [r0, #60]	; 0x3c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
     9b8:	6966      	ldr	r6, [r4, #20]
     9ba:	6146      	str	r6, [r0, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
     9bc:	2200      	movs	r2, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
     9be:	f100 0528 	add.w	r5, r0, #40	; 0x28
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
     9c2:	f04f 0802 	mov.w	r8, #2
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
     9c6:	f04f 0c14 	mov.w	ip, #20
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
     9ca:	f04f 0e01 	mov.w	lr, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
     9ce:	f100 0724 	add.w	r7, r0, #36	; 0x24
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
     9d2:	6081      	str	r1, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
     9d4:	6104      	str	r4, [r0, #16]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
     9d6:	f880 801c 	strb.w	r8, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
     9da:	f880 c01f 	strb.w	ip, [r0, #31]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
     9de:	f880 e01e 	strb.w	lr, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
     9e2:	7742      	strb	r2, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
     9e4:	6382      	str	r2, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
     9e6:	6342      	str	r2, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
     9e8:	6182      	str	r2, [r0, #24]
  REG_INSERT(tp);
     9ea:	6130      	str	r0, [r6, #16]
     9ec:	6160      	str	r0, [r4, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
     9ee:	6247      	str	r7, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
     9f0:	6285      	str	r5, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
     9f2:	62c5      	str	r5, [r0, #44]	; 0x2c
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
     9f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     9f8:	1fffe608 	.word	0x1fffe608
     9fc:	f3af 8000 	nop.w

00000a00 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
     a00:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
     a04:	4696      	mov	lr, r2
     a06:	4604      	mov	r4, r0
     a08:	2220      	movs	r2, #32
     a0a:	f382 8811 	msr	BASEPRI, r2
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
     a0e:	4e1a      	ldr	r6, [pc, #104]	; (a78 <chThdCreateStatic+0x78>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
     a10:	f8df b068 	ldr.w	fp, [pc, #104]	; a7c <chThdCreateStatic+0x7c>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
     a14:	6972      	ldr	r2, [r6, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
     a16:	3924      	subs	r1, #36	; 0x24
     a18:	1847      	adds	r7, r0, r1
     a1a:	60c7      	str	r7, [r0, #12]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
     a1c:	2500      	movs	r5, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
     a1e:	5043      	str	r3, [r0, r1]
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
     a20:	f100 0c24 	add.w	ip, r0, #36	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
     a24:	f100 0328 	add.w	r3, r0, #40	; 0x28

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
     a28:	990a      	ldr	r1, [sp, #40]	; 0x28
     a2a:	6079      	str	r1, [r7, #4]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
     a2c:	f04f 0a02 	mov.w	sl, #2
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
     a30:	f04f 0914 	mov.w	r9, #20
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
     a34:	f04f 0801 	mov.w	r8, #1

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
     a38:	f8c7 b020 	str.w	fp, [r7, #32]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
     a3c:	4629      	mov	r1, r5
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
     a3e:	f8c0 e008 	str.w	lr, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
     a42:	6106      	str	r6, [r0, #16]
     a44:	6142      	str	r2, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
     a46:	f8c0 e03c 	str.w	lr, [r0, #60]	; 0x3c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
     a4a:	f880 a01c 	strb.w	sl, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
     a4e:	f880 901f 	strb.w	r9, [r0, #31]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
     a52:	f880 801e 	strb.w	r8, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
     a56:	7745      	strb	r5, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
     a58:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
     a5a:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
     a5c:	6185      	str	r5, [r0, #24]
  REG_INSERT(tp);
     a5e:	6110      	str	r0, [r2, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
     a60:	f8c0 c024 	str.w	ip, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
     a64:	6283      	str	r3, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
     a66:	62c3      	str	r3, [r0, #44]	; 0x2c
     a68:	6170      	str	r0, [r6, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
     a6a:	f7ff ff09 	bl	880 <chSchWakeupS>
     a6e:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
     a72:	4620      	mov	r0, r4
     a74:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
     a78:	1fffe608 	.word	0x1fffe608
     a7c:	00000501 	.word	0x00000501

00000a80 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
     a80:	b508      	push	{r3, lr}
     a82:	4601      	mov	r1, r0
     a84:	2320      	movs	r3, #32
     a86:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
     a8a:	2008      	movs	r0, #8
     a8c:	f7ff fed0 	bl	830 <chSchGoSleepTimeoutS>
     a90:	2300      	movs	r3, #0
     a92:	f383 8811 	msr	BASEPRI, r3
     a96:	bd08      	pop	{r3, pc}
     a98:	f3af 8000 	nop.w
     a9c:	f3af 8000 	nop.w

00000aa0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
     aa0:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
     aa2:	4b0e      	ldr	r3, [pc, #56]	; (adc <chThdExitS+0x3c>)
     aa4:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
     aa6:	6a63      	ldr	r3, [r4, #36]	; 0x24

  tp->p_u.exitcode = msg;
     aa8:	6220      	str	r0, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
     aaa:	f104 0524 	add.w	r5, r4, #36	; 0x24
     aae:	429d      	cmp	r5, r3
     ab0:	d007      	beq.n	ac2 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
     ab2:	681a      	ldr	r2, [r3, #0]
     ab4:	6262      	str	r2, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
     ab6:	4618      	mov	r0, r3
     ab8:	f7ff fe8a 	bl	7d0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
     abc:	6a63      	ldr	r3, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
     abe:	42ab      	cmp	r3, r5
     ac0:	d1f7      	bne.n	ab2 <chThdExitS+0x12>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
     ac2:	7f63      	ldrb	r3, [r4, #29]
     ac4:	079b      	lsls	r3, r3, #30
     ac6:	d104      	bne.n	ad2 <chThdExitS+0x32>
    REG_REMOVE(tp);
     ac8:	6963      	ldr	r3, [r4, #20]
     aca:	6922      	ldr	r2, [r4, #16]
     acc:	611a      	str	r2, [r3, #16]
     ace:	6922      	ldr	r2, [r4, #16]
     ad0:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
     ad2:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
     ad4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
     ad8:	f7ff be92 	b.w	800 <chSchGoSleepS>
     adc:	1fffe608 	.word	0x1fffe608

00000ae0 <chThdExit>:
     ae0:	2320      	movs	r3, #32
     ae2:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
     ae6:	f7ff bfdb 	b.w	aa0 <chThdExitS>
     aea:	bf00      	nop
     aec:	f3af 8000 	nop.w

00000af0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
     af0:	b169      	cbz	r1, b0e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
     af2:	4b08      	ldr	r3, [pc, #32]	; (b14 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
     af4:	b410      	push	{r4}
     af6:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
     af8:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
     afa:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
     afc:	2004      	movs	r0, #4
     afe:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
     b02:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
     b04:	6053      	str	r3, [r2, #4]
}
     b06:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
     b0a:	f7ff be91 	b.w	830 <chSchGoSleepTimeoutS>
}
     b0e:	f04f 30ff 	mov.w	r0, #4294967295
     b12:	4770      	bx	lr
     b14:	1fffe608 	.word	0x1fffe608
     b18:	f3af 8000 	nop.w
     b1c:	f3af 8000 	nop.w

00000b20 <chThdDequeueNextI>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
     b20:	6802      	ldr	r2, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
     b22:	4290      	cmp	r0, r2
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
     b24:	4603      	mov	r3, r0

  if (queue_notempty(tqp)) {
     b26:	d009      	beq.n	b3c <chThdDequeueNextI+0x1c>
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
     b28:	b410      	push	{r4}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
     b2a:	6814      	ldr	r4, [r2, #0]
     b2c:	6004      	str	r4, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
     b2e:	6063      	str	r3, [r4, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
     b30:	6211      	str	r1, [r2, #32]
  (void) chSchReadyI(tp);
     b32:	4610      	mov	r0, r2

  if (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
  }
}
     b34:	f85d 4b04 	ldr.w	r4, [sp], #4
     b38:	f7ff be4a 	b.w	7d0 <chSchReadyI>
     b3c:	4770      	bx	lr
     b3e:	bf00      	nop

00000b40 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
     b40:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
     b42:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
     b44:	6040      	str	r0, [r0, #4]
     b46:	6083      	str	r3, [r0, #8]
     b48:	4770      	bx	lr
     b4a:	bf00      	nop
     b4c:	f3af 8000 	nop.w

00000b50 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
     b50:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
     b52:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
     b54:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
     b56:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
     b58:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
     b5a:	d00a      	beq.n	b72 <chEvtSignalI+0x22>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
     b5c:	2a0b      	cmp	r2, #11
     b5e:	d000      	beq.n	b62 <chEvtSignalI+0x12>
     b60:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
     b62:	6a03      	ldr	r3, [r0, #32]
     b64:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
     b66:	428b      	cmp	r3, r1
     b68:	d1fa      	bne.n	b60 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
     b6a:	2300      	movs	r3, #0
     b6c:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
     b6e:	f7ff be2f 	b.w	7d0 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
     b72:	6a03      	ldr	r3, [r0, #32]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
     b74:	4219      	tst	r1, r3
     b76:	d1f8      	bne.n	b6a <chEvtSignalI+0x1a>
     b78:	4770      	bx	lr
     b7a:	bf00      	nop
     b7c:	f3af 8000 	nop.w

00000b80 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
     b80:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
     b82:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
     b84:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
     b86:	4606      	mov	r6, r0
     b88:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
     b8a:	d00d      	beq.n	ba8 <chEvtBroadcastFlagsI+0x28>
  /*lint -restore*/
    elp->el_flags |= flags;
     b8c:	68e3      	ldr	r3, [r4, #12]
     b8e:	432b      	orrs	r3, r5
     b90:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
     b92:	b115      	cbz	r5, b9a <chEvtBroadcastFlagsI+0x1a>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
     b94:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
     b96:	4213      	tst	r3, r2
     b98:	d003      	beq.n	ba2 <chEvtBroadcastFlagsI+0x22>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
     b9a:	6860      	ldr	r0, [r4, #4]
     b9c:	68a1      	ldr	r1, [r4, #8]
     b9e:	f7ff ffd7 	bl	b50 <chEvtSignalI>
    }
    elp = elp->el_next;
     ba2:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
     ba4:	42a6      	cmp	r6, r4
     ba6:	d1f1      	bne.n	b8c <chEvtBroadcastFlagsI+0xc>
     ba8:	bd70      	pop	{r4, r5, r6, pc}
     baa:	bf00      	nop
     bac:	f3af 8000 	nop.w

00000bb0 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
     bb0:	b430      	push	{r4, r5}
     bb2:	9c02      	ldr	r4, [sp, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
     bb4:	6204      	str	r4, [r0, #32]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
     bb6:	2500      	movs	r5, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
     bb8:	440a      	add	r2, r1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
     bba:	6085      	str	r5, [r0, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
     bbc:	6102      	str	r2, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
     bbe:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
     bc0:	6040      	str	r0, [r0, #4]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
     bc2:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
     bc4:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
     bc6:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
     bc8:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
}
     bca:	bc30      	pop	{r4, r5}
     bcc:	4770      	bx	lr
     bce:	bf00      	nop

00000bd0 <chIQPutI>:
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
     bd0:	6943      	ldr	r3, [r0, #20]
     bd2:	6982      	ldr	r2, [r0, #24]
     bd4:	4293      	cmp	r3, r2
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
     bd6:	b510      	push	{r4, lr}
     bd8:	d010      	beq.n	bfc <chIQPutI+0x2c>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
     bda:	6882      	ldr	r2, [r0, #8]
  *iqp->q_wrptr++ = b;
     bdc:	1c5c      	adds	r4, r3, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
     bde:	3201      	adds	r2, #1
     be0:	6082      	str	r2, [r0, #8]
  *iqp->q_wrptr++ = b;
     be2:	6144      	str	r4, [r0, #20]
     be4:	7019      	strb	r1, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
     be6:	6942      	ldr	r2, [r0, #20]
     be8:	6903      	ldr	r3, [r0, #16]
     bea:	429a      	cmp	r2, r3
     bec:	d301      	bcc.n	bf2 <chIQPutI+0x22>
    iqp->q_wrptr = iqp->q_buffer;
     bee:	68c3      	ldr	r3, [r0, #12]
     bf0:	6143      	str	r3, [r0, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
     bf2:	2100      	movs	r1, #0
     bf4:	f7ff ff94 	bl	b20 <chThdDequeueNextI>

  return Q_OK;
     bf8:	2000      	movs	r0, #0
     bfa:	bd10      	pop	{r4, pc}
     bfc:	6882      	ldr	r2, [r0, #8]
     bfe:	2a00      	cmp	r2, #0
     c00:	d0eb      	beq.n	bda <chIQPutI+0xa>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
     c02:	f06f 0003 	mvn.w	r0, #3
     c06:	bd10      	pop	{r4, pc}
     c08:	f3af 8000 	nop.w
     c0c:	f3af 8000 	nop.w

00000c10 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
     c10:	b570      	push	{r4, r5, r6, lr}
     c12:	2320      	movs	r3, #32
     c14:	460e      	mov	r6, r1
     c16:	4604      	mov	r4, r0
     c18:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
     c1c:	69c3      	ldr	r3, [r0, #28]
     c1e:	b12b      	cbz	r3, c2c <chIQGetTimeout+0x1c>
    iqp->q_notify(iqp);
     c20:	4798      	blx	r3
     c22:	e003      	b.n	c2c <chIQGetTimeout+0x1c>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
     c24:	f7ff ff64 	bl	af0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
     c28:	2800      	cmp	r0, #0
     c2a:	db15      	blt.n	c58 <chIQGetTimeout+0x48>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
     c2c:	68a5      	ldr	r5, [r4, #8]
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
     c2e:	4620      	mov	r0, r4
     c30:	4631      	mov	r1, r6
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
     c32:	2d00      	cmp	r5, #0
     c34:	d0f6      	beq.n	c24 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
     c36:	69a1      	ldr	r1, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
     c38:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
     c3a:	6925      	ldr	r5, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
     c3c:	1c4a      	adds	r2, r1, #1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
     c3e:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
     c40:	42aa      	cmp	r2, r5
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
     c42:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
     c44:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
     c46:	bf28      	it	cs
     c48:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
     c4a:	7808      	ldrb	r0, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
     c4c:	bf28      	it	cs
     c4e:	61a3      	strcs	r3, [r4, #24]
     c50:	2300      	movs	r3, #0
     c52:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
}
     c56:	bd70      	pop	{r4, r5, r6, pc}
     c58:	f385 8811 	msr	BASEPRI, r5

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < Q_OK) {
      chSysUnlock();
      return msg;
     c5c:	bd70      	pop	{r4, r5, r6, pc}
     c5e:	bf00      	nop

00000c60 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
     c60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     c64:	4604      	mov	r4, r0
     c66:	b083      	sub	sp, #12
     c68:	4689      	mov	r9, r1
     c6a:	4693      	mov	fp, r2
     c6c:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
     c6e:	f8d0 801c 	ldr.w	r8, [r0, #28]
     c72:	2720      	movs	r7, #32
     c74:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
     c78:	2600      	movs	r6, #0
     c7a:	9701      	str	r7, [sp, #4]
     c7c:	46b2      	mov	sl, r6

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
     c7e:	f1b8 0f00 	cmp.w	r8, #0
     c82:	d005      	beq.n	c90 <chIQReadTimeout+0x30>
      nfy(iqp);
     c84:	4620      	mov	r0, r4
     c86:	47c0      	blx	r8
     c88:	e002      	b.n	c90 <chIQReadTimeout+0x30>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
     c8a:	f7ff ff31 	bl	af0 <chThdEnqueueTimeoutS>
     c8e:	b9e0      	cbnz	r0, cca <chIQReadTimeout+0x6a>
     c90:	68a7      	ldr	r7, [r4, #8]
     c92:	4620      	mov	r0, r4
     c94:	4629      	mov	r1, r5
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
     c96:	2f00      	cmp	r7, #0
     c98:	d0f7      	beq.n	c8a <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
     c9a:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
     c9c:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
     c9e:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
     ca0:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
     ca2:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
     ca4:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
     ca6:	7813      	ldrb	r3, [r2, #0]
     ca8:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top) {
     cac:	6923      	ldr	r3, [r4, #16]
     cae:	69a2      	ldr	r2, [r4, #24]
     cb0:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
     cb2:	bf24      	itt	cs
     cb4:	68e3      	ldrcs	r3, [r4, #12]
     cb6:	61a3      	strcs	r3, [r4, #24]
     cb8:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
     cbc:	3601      	adds	r6, #1
    if (--n == 0U) {
     cbe:	45b3      	cmp	fp, r6
     cc0:	d005      	beq.n	cce <chIQReadTimeout+0x6e>
     cc2:	9b01      	ldr	r3, [sp, #4]
     cc4:	f383 8811 	msr	BASEPRI, r3
     cc8:	e7d9      	b.n	c7e <chIQReadTimeout+0x1e>
     cca:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
     cce:	4630      	mov	r0, r6
     cd0:	b003      	add	sp, #12
     cd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     cd6:	bf00      	nop
     cd8:	f3af 8000 	nop.w
     cdc:	f3af 8000 	nop.w

00000ce0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
     ce0:	b430      	push	{r4, r5}
     ce2:	9c02      	ldr	r4, [sp, #8]
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
     ce4:	6204      	str	r4, [r0, #32]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
     ce6:	188d      	adds	r5, r1, r2
     ce8:	6105      	str	r5, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
     cea:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
     cec:	6040      	str	r0, [r0, #4]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
     cee:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
     cf0:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
     cf2:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
     cf4:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
     cf6:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
}
     cf8:	bc30      	pop	{r4, r5}
     cfa:	4770      	bx	lr
     cfc:	f3af 8000 	nop.w

00000d00 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
     d00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     d02:	4604      	mov	r4, r0
     d04:	460f      	mov	r7, r1
     d06:	4616      	mov	r6, r2
     d08:	2320      	movs	r3, #32
     d0a:	f383 8811 	msr	BASEPRI, r3
     d0e:	e003      	b.n	d18 <chOQPutTimeout+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
     d10:	f7ff feee 	bl	af0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
     d14:	2800      	cmp	r0, #0
     d16:	db19      	blt.n	d4c <chOQPutTimeout+0x4c>
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
     d18:	68a5      	ldr	r5, [r4, #8]
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
     d1a:	4620      	mov	r0, r4
     d1c:	4631      	mov	r1, r6
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
     d1e:	2d00      	cmp	r5, #0
     d20:	d0f6      	beq.n	d10 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
     d22:	6962      	ldr	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
     d24:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
     d26:	1c51      	adds	r1, r2, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
     d28:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
     d2a:	6161      	str	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
     d2c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
     d2e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
     d30:	6923      	ldr	r3, [r4, #16]
     d32:	6962      	ldr	r2, [r4, #20]
     d34:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
     d36:	bf24      	itt	cs
     d38:	68e3      	ldrcs	r3, [r4, #12]
     d3a:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
     d3c:	69e3      	ldr	r3, [r4, #28]
     d3e:	b10b      	cbz	r3, d44 <chOQPutTimeout+0x44>
    oqp->q_notify(oqp);
     d40:	4620      	mov	r0, r4
     d42:	4798      	blx	r3
     d44:	2000      	movs	r0, #0
     d46:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
     d4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     d4c:	f385 8811 	msr	BASEPRI, r5
  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < Q_OK) {
      chSysUnlock();
      return msg;
     d50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     d52:	bf00      	nop
     d54:	f3af 8000 	nop.w
     d58:	f3af 8000 	nop.w
     d5c:	f3af 8000 	nop.w

00000d60 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
     d60:	b538      	push	{r3, r4, r5, lr}
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
     d62:	6942      	ldr	r2, [r0, #20]
     d64:	6983      	ldr	r3, [r0, #24]
     d66:	429a      	cmp	r2, r3
     d68:	d00f      	beq.n	d8a <chOQGetI+0x2a>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
     d6a:	6882      	ldr	r2, [r0, #8]
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
     d6c:	6905      	ldr	r5, [r0, #16]
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
     d6e:	1c59      	adds	r1, r3, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
     d70:	3201      	adds	r2, #1
     d72:	6082      	str	r2, [r0, #8]
  b = *oqp->q_rdptr++;
     d74:	6181      	str	r1, [r0, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
     d76:	42a9      	cmp	r1, r5
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
     d78:	781c      	ldrb	r4, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
     d7a:	d301      	bcc.n	d80 <chOQGetI+0x20>
    oqp->q_rdptr = oqp->q_buffer;
     d7c:	68c3      	ldr	r3, [r0, #12]
     d7e:	6183      	str	r3, [r0, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
     d80:	2100      	movs	r1, #0
     d82:	f7ff fecd 	bl	b20 <chThdDequeueNextI>

  return (msg_t)b;
     d86:	4620      	mov	r0, r4
     d88:	bd38      	pop	{r3, r4, r5, pc}
     d8a:	6882      	ldr	r2, [r0, #8]
     d8c:	2a00      	cmp	r2, #0
     d8e:	d0ec      	beq.n	d6a <chOQGetI+0xa>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
     d90:	f06f 0002 	mvn.w	r0, #2
     d94:	bd38      	pop	{r3, r4, r5, pc}
     d96:	bf00      	nop
     d98:	f3af 8000 	nop.w
     d9c:	f3af 8000 	nop.w

00000da0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
     da0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     da4:	b083      	sub	sp, #12
     da6:	4604      	mov	r4, r0
     da8:	468b      	mov	fp, r1
     daa:	4616      	mov	r6, r2
     dac:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
     dae:	f8d0 801c 	ldr.w	r8, [r0, #28]
     db2:	f04f 0920 	mov.w	r9, #32
     db6:	f389 8811 	msr	BASEPRI, r9
  size_t w = 0;
     dba:	2700      	movs	r7, #0
     dbc:	f8cd 9000 	str.w	r9, [sp]
     dc0:	46ba      	mov	sl, r7
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
     dc2:	68a5      	ldr	r5, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
     dc4:	f10b 0901 	add.w	r9, fp, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
     dc8:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
     dca:	b315      	cbz	r5, e12 <chOQWriteTimeout+0x72>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
     dcc:	6963      	ldr	r3, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
     dce:	68a5      	ldr	r5, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
     dd0:	1c59      	adds	r1, r3, #1
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
     dd2:	3d01      	subs	r5, #1
    *oqp->q_wrptr++ = *bp++;
     dd4:	6161      	str	r1, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
     dd6:	60a5      	str	r5, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
     dd8:	f89b 1000 	ldrb.w	r1, [fp]
     ddc:	7019      	strb	r1, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
     dde:	6923      	ldr	r3, [r4, #16]
     de0:	6961      	ldr	r1, [r4, #20]
     de2:	4299      	cmp	r1, r3
      oqp->q_wrptr = oqp->q_buffer;
     de4:	bf24      	itt	cs
     de6:	68e3      	ldrcs	r3, [r4, #12]
     de8:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
     dea:	f1b8 0f00 	cmp.w	r8, #0
     dee:	d000      	beq.n	df2 <chOQWriteTimeout+0x52>
      nfy(oqp);
     df0:	47c0      	blx	r8
     df2:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
     df6:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
     df8:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
     dfc:	d011      	beq.n	e22 <chOQWriteTimeout+0x82>
     dfe:	9b00      	ldr	r3, [sp, #0]
     e00:	f383 8811 	msr	BASEPRI, r3
     e04:	68a5      	ldr	r5, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
     e06:	46cb      	mov	fp, r9
     e08:	f10b 0901 	add.w	r9, fp, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
     e0c:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
     e0e:	2d00      	cmp	r5, #0
     e10:	d1dc      	bne.n	dcc <chOQWriteTimeout+0x2c>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
     e12:	4620      	mov	r0, r4
     e14:	9901      	ldr	r1, [sp, #4]
     e16:	f7ff fe6b 	bl	af0 <chThdEnqueueTimeoutS>
     e1a:	2800      	cmp	r0, #0
     e1c:	d0d1      	beq.n	dc2 <chOQWriteTimeout+0x22>
     e1e:	f385 8811 	msr	BASEPRI, r5
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
     e22:	4638      	mov	r0, r7
     e24:	b003      	add	sp, #12
     e26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     e2a:	bf00      	nop
     e2c:	f3af 8000 	nop.w

00000e30 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
     e30:	4a05      	ldr	r2, [pc, #20]	; (e48 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
     e32:	4b06      	ldr	r3, [pc, #24]	; (e4c <_core_init+0x1c>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
     e34:	4806      	ldr	r0, [pc, #24]	; (e50 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
     e36:	4907      	ldr	r1, [pc, #28]	; (e54 <_core_init+0x24>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
     e38:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
     e3c:	f023 0307 	bic.w	r3, r3, #7
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
     e40:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
     e42:	600b      	str	r3, [r1, #0]
     e44:	4770      	bx	lr
     e46:	bf00      	nop
     e48:	1fffe857 	.word	0x1fffe857
     e4c:	20002000 	.word	0x20002000
     e50:	1fffe75c 	.word	0x1fffe75c
     e54:	1fffe758 	.word	0x1fffe758
     e58:	f3af 8000 	nop.w
     e5c:	f3af 8000 	nop.w

00000e60 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
     e60:	b410      	push	{r4}
     e62:	2320      	movs	r3, #32
     e64:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
     e68:	4c09      	ldr	r4, [pc, #36]	; (e90 <chCoreAlloc+0x30>)
     e6a:	4b0a      	ldr	r3, [pc, #40]	; (e94 <chCoreAlloc+0x34>)
     e6c:	6822      	ldr	r2, [r4, #0]
     e6e:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
     e70:	1dc3      	adds	r3, r0, #7
     e72:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
     e76:	1a89      	subs	r1, r1, r2
     e78:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
     e7a:	bf9d      	ittte	ls
     e7c:	189b      	addls	r3, r3, r2
     e7e:	6023      	strls	r3, [r4, #0]

  return p;
     e80:	4610      	movls	r0, r2

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
     e82:	2000      	movhi	r0, #0
     e84:	2300      	movs	r3, #0
     e86:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
     e8a:	f85d 4b04 	ldr.w	r4, [sp], #4
     e8e:	4770      	bx	lr
     e90:	1fffe75c 	.word	0x1fffe75c
     e94:	1fffe758 	.word	0x1fffe758
     e98:	f3af 8000 	nop.w
     e9c:	f3af 8000 	nop.w

00000ea0 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
     ea0:	4a02      	ldr	r2, [pc, #8]	; (eac <chCoreGetStatusX+0xc>)
     ea2:	4b03      	ldr	r3, [pc, #12]	; (eb0 <chCoreGetStatusX+0x10>)
     ea4:	6810      	ldr	r0, [r2, #0]
     ea6:	681b      	ldr	r3, [r3, #0]
  /*lint -restore*/
}
     ea8:	1ac0      	subs	r0, r0, r3
     eaa:	4770      	bx	lr
     eac:	1fffe758 	.word	0x1fffe758
     eb0:	1fffe75c 	.word	0x1fffe75c
     eb4:	f3af 8000 	nop.w
     eb8:	f3af 8000 	nop.w
     ebc:	f3af 8000 	nop.w

00000ec0 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
     ec0:	4b04      	ldr	r3, [pc, #16]	; (ed4 <_heap_init+0x14>)
     ec2:	4a05      	ldr	r2, [pc, #20]	; (ed8 <_heap_init+0x18>)
     ec4:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
  default_heap.h_free.h.size = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
     ec6:	f103 0010 	add.w	r0, r3, #16
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
  default_heap.h_free.h.u.next = NULL;
     eca:	2200      	movs	r2, #0
     ecc:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
     ece:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
     ed0:	f7ff be36 	b.w	b40 <chMtxObjectInit>
     ed4:	1fffe760 	.word	0x1fffe760
     ed8:	00000e61 	.word	0x00000e61
     edc:	f3af 8000 	nop.w

00000ee0 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
     ee0:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
     ee4:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
     ee6:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     eea:	2300      	movs	r3, #0
     eec:	f383 8811 	msr	BASEPRI, r3
     ef0:	4770      	bx	lr
     ef2:	bf00      	nop
     ef4:	f3af 8000 	nop.w
     ef8:	f3af 8000 	nop.w
     efc:	f3af 8000 	nop.w

00000f00 <_port_irq_epilogue>:
     f00:	2320      	movs	r3, #32
     f02:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
     f06:	4b0f      	ldr	r3, [pc, #60]	; (f44 <_port_irq_epilogue+0x44>)
     f08:	685b      	ldr	r3, [r3, #4]
     f0a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
     f0e:	d102      	bne.n	f16 <_port_irq_epilogue+0x16>
     f10:	f383 8811 	msr	BASEPRI, r3
     f14:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
     f16:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
     f18:	f3ef 8409 	mrs	r4, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
     f1c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
     f20:	f844 3c04 	str.w	r3, [r4, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
     f24:	f1a4 0320 	sub.w	r3, r4, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
     f28:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
     f2c:	f7ff fcd8 	bl	8e0 <chSchIsPreemptionRequired>
     f30:	b118      	cbz	r0, f3a <_port_irq_epilogue+0x3a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
     f32:	4b05      	ldr	r3, [pc, #20]	; (f48 <_port_irq_epilogue+0x48>)
     f34:	f844 3c08 	str.w	r3, [r4, #-8]
     f38:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
     f3a:	4b04      	ldr	r3, [pc, #16]	; (f4c <_port_irq_epilogue+0x4c>)
     f3c:	f844 3c08 	str.w	r3, [r4, #-8]
     f40:	bd10      	pop	{r4, pc}
     f42:	bf00      	nop
     f44:	e000ed00 	.word	0xe000ed00
     f48:	00000511 	.word	0x00000511
     f4c:	00000514 	.word	0x00000514

00000f50 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
     f50:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
     f52:	f000 f8dd 	bl	1110 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
     f56:	4806      	ldr	r0, [pc, #24]	; (f70 <halInit+0x20>)
     f58:	f000 f9ea 	bl	1330 <_pal_lld_init>
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
     f5c:	f000 f818 	bl	f90 <extInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
     f60:	f000 f876 	bl	1050 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
     f64:	f000 fc7c 	bl	1860 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
     f68:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
     f6c:	f000 b808 	b.w	f80 <stInit>
     f70:	00001e40 	.word	0x00001e40
     f74:	f3af 8000 	nop.w
     f78:	f3af 8000 	nop.w
     f7c:	f3af 8000 	nop.w

00000f80 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
     f80:	f000 bc56 	b.w	1830 <st_lld_init>
     f84:	f3af 8000 	nop.w
     f88:	f3af 8000 	nop.w
     f8c:	f3af 8000 	nop.w

00000f90 <extInit>:
 *
 * @init
 */
void extInit(void) {

  ext_lld_init();
     f90:	f000 bba6 	b.w	16e0 <ext_lld_init>
     f94:	f3af 8000 	nop.w
     f98:	f3af 8000 	nop.w
     f9c:	f3af 8000 	nop.w

00000fa0 <extObjectInit>:
 * @init
 */
void extObjectInit(EXTDriver *extp) {

  extp->state  = EXT_STOP;
  extp->config = NULL;
     fa0:	2201      	movs	r2, #1
     fa2:	2300      	movs	r3, #0
     fa4:	e880 000c 	stmia.w	r0, {r2, r3}
     fa8:	4770      	bx	lr
     faa:	bf00      	nop
     fac:	f3af 8000 	nop.w

00000fb0 <extStart>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] config    pointer to the @p EXTConfig object
 *
 * @api
 */
void extStart(EXTDriver *extp, const EXTConfig *config) {
     fb0:	b510      	push	{r4, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     fb2:	2320      	movs	r3, #32
     fb4:	4604      	mov	r4, r0
     fb6:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((extp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  extp->config = config;
     fba:	6041      	str	r1, [r0, #4]
  ext_lld_start(extp);
     fbc:	f000 fbb8 	bl	1730 <ext_lld_start>
  extp->state = EXT_ACTIVE;
     fc0:	2302      	movs	r3, #2
     fc2:	6023      	str	r3, [r4, #0]
     fc4:	2300      	movs	r3, #0
     fc6:	f383 8811 	msr	BASEPRI, r3
     fca:	bd10      	pop	{r4, pc}
     fcc:	f3af 8000 	nop.w

00000fd0 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
     fd0:	300c      	adds	r0, #12
     fd2:	f7ff be45 	b.w	c60 <chIQReadTimeout>
     fd6:	bf00      	nop
     fd8:	f3af 8000 	nop.w
     fdc:	f3af 8000 	nop.w

00000fe0 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
     fe0:	300c      	adds	r0, #12
     fe2:	f04f 33ff 	mov.w	r3, #4294967295
     fe6:	f7ff be3b 	b.w	c60 <chIQReadTimeout>
     fea:	bf00      	nop
     fec:	f3af 8000 	nop.w

00000ff0 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
     ff0:	3030      	adds	r0, #48	; 0x30
     ff2:	f7ff bed5 	b.w	da0 <chOQWriteTimeout>
     ff6:	bf00      	nop
     ff8:	f3af 8000 	nop.w
     ffc:	f3af 8000 	nop.w

00001000 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    1000:	3030      	adds	r0, #48	; 0x30
    1002:	f04f 33ff 	mov.w	r3, #4294967295
    1006:	f7ff becb 	b.w	da0 <chOQWriteTimeout>
    100a:	bf00      	nop
    100c:	f3af 8000 	nop.w

00001010 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    1010:	300c      	adds	r0, #12
    1012:	f7ff bdfd 	b.w	c10 <chIQGetTimeout>
    1016:	bf00      	nop
    1018:	f3af 8000 	nop.w
    101c:	f3af 8000 	nop.w

00001020 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    1020:	300c      	adds	r0, #12
    1022:	f04f 31ff 	mov.w	r1, #4294967295
    1026:	f7ff bdf3 	b.w	c10 <chIQGetTimeout>
    102a:	bf00      	nop
    102c:	f3af 8000 	nop.w

00001030 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    1030:	3030      	adds	r0, #48	; 0x30
    1032:	f7ff be65 	b.w	d00 <chOQPutTimeout>
    1036:	bf00      	nop
    1038:	f3af 8000 	nop.w
    103c:	f3af 8000 	nop.w

00001040 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    1040:	3030      	adds	r0, #48	; 0x30
    1042:	f04f 32ff 	mov.w	r2, #4294967295
    1046:	f7ff be5b 	b.w	d00 <chOQPutTimeout>
    104a:	bf00      	nop
    104c:	f3af 8000 	nop.w

00001050 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    1050:	f000 b9fe 	b.w	1450 <sd_lld_init>
    1054:	f3af 8000 	nop.w
    1058:	f3af 8000 	nop.w
    105c:	f3af 8000 	nop.w

00001060 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    1060:	b570      	push	{r4, r5, r6, lr}

  sdp->vmt = &vmt;
    1062:	4b0e      	ldr	r3, [pc, #56]	; (109c <sdObjectInit+0x3c>)
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    1064:	4604      	mov	r4, r0
    1066:	b082      	sub	sp, #8

  sdp->vmt = &vmt;
    1068:	f840 3b04 	str.w	r3, [r0], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
    106c:	2601      	movs	r6, #1
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    106e:	9400      	str	r4, [sp, #0]
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    1070:	460b      	mov	r3, r1
    1072:	4615      	mov	r5, r2
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
    1074:	6060      	str	r0, [r4, #4]

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    1076:	f104 0154 	add.w	r1, r4, #84	; 0x54
    107a:	f104 000c 	add.w	r0, r4, #12
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
    107e:	60a6      	str	r6, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    1080:	2210      	movs	r2, #16
    1082:	f7ff fd95 	bl	bb0 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    1086:	9400      	str	r4, [sp, #0]
    1088:	462b      	mov	r3, r5
    108a:	f104 0030 	add.w	r0, r4, #48	; 0x30
    108e:	f104 0164 	add.w	r1, r4, #100	; 0x64
    1092:	2210      	movs	r2, #16
    1094:	f7ff fe24 	bl	ce0 <chOQObjectInit>
}
    1098:	b002      	add	sp, #8
    109a:	bd70      	pop	{r4, r5, r6, pc}
    109c:	00001e10 	.word	0x00001e10

000010a0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    10a0:	b510      	push	{r4, lr}
    10a2:	2320      	movs	r3, #32
    10a4:	4604      	mov	r4, r0
    10a6:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    10aa:	f000 f9e1 	bl	1470 <sd_lld_start>
  sdp->state = SD_READY;
    10ae:	2302      	movs	r3, #2
    10b0:	60a3      	str	r3, [r4, #8]
    10b2:	2300      	movs	r3, #0
    10b4:	f383 8811 	msr	BASEPRI, r3
    10b8:	bd10      	pop	{r4, pc}
    10ba:	bf00      	nop
    10bc:	f3af 8000 	nop.w

000010c0 <nvicEnableVector>:
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
    10c0:	0943      	lsrs	r3, r0, #5
    10c2:	009b      	lsls	r3, r3, #2
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
    10c4:	b410      	push	{r4}
    10c6:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
    10ca:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
    10ce:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
    10d2:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    10d6:	0109      	lsls	r1, r1, #4
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
    10d8:	f000 001f 	and.w	r0, r0, #31
    10dc:	2201      	movs	r2, #1
    10de:	4082      	lsls	r2, r0

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
    10e0:	b2c9      	uxtb	r1, r1
    10e2:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
    10e6:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
    10ea:	601a      	str	r2, [r3, #0]
}
    10ec:	f85d 4b04 	ldr.w	r4, [sp], #4
    10f0:	4770      	bx	lr
    10f2:	bf00      	nop
    10f4:	f3af 8000 	nop.w
    10f8:	f3af 8000 	nop.w
    10fc:	f3af 8000 	nop.w

00001100 <nvicSetSystemHandlerPriority>:
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
    1100:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
    1104:	f500 406d 	add.w	r0, r0, #60672	; 0xed00
    1108:	0109      	lsls	r1, r1, #4
    110a:	b2c9      	uxtb	r1, r1
    110c:	7601      	strb	r1, [r0, #24]
    110e:	4770      	bx	lr

00001110 <hal_lld_init>:
 * @brief   Low level HAL driver initialization.
 * @todo    Use a macro to define the system clock frequency.
 *
 * @notapi
 */
void hal_lld_init(void) {
    1110:	4770      	bx	lr
    1112:	bf00      	nop
    1114:	f3af 8000 	nop.w
    1118:	f3af 8000 	nop.w
    111c:	f3af 8000 	nop.w

00001120 <mk20d50_clock_init>:
 *          @p board.c.
 * @todo    This function needs to be more generic.
 *
 * @special
 */
void mk20d50_clock_init(void) {
    1120:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#if !KINETIS_NO_INIT

#if KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE
  uint32_t ratio, frdiv;
  uint32_t ratios[] = { 32, 64, 128, 256, 512, 1024, 1280, 1536 };
    1124:	4d35      	ldr	r5, [pc, #212]	; (11fc <mk20d50_clock_init+0xdc>)
  int ratio_quantity = sizeof(ratios) / sizeof(ratios[0]);
  int i;
#endif /* KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE */

  /* Disable the watchdog */
  WDOG->UNLOCK = 0xC520;
    1126:	4e36      	ldr	r6, [pc, #216]	; (1200 <mk20d50_clock_init+0xe0>)
  WDOG->UNLOCK = 0xD928;
  WDOG->STCTRLH &= ~WDOG_STCTRLH_WDOGEN;

  SIM->SCGC5 |= SIM_SCGC5_PORTA |
    1128:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 1208 <mk20d50_clock_init+0xe8>
  /* TODO: need to add more flexible calculation, specially regarding
   *       divisors which may not be available depending on the XTAL
   *       frequency, which would required other registers to be modified.
   */
  /* Enable OSC, low power mode */
  MCG->C2 = MCG_C2_LOCRE0 | MCG_C2_EREFS0;
    112c:	4f35      	ldr	r7, [pc, #212]	; (1204 <mk20d50_clock_init+0xe4>)
#endif /* KINETIS_MCG_MODE == KINETIS_MCG_MODE_FEI */

#if KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE

  /* EXTAL0 and XTAL0 */
  PORTA->PCR[18] = 0;
    112e:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 120c <mk20d50_clock_init+0xec>
  /*
   * Start in FEI mode
   */

  /* Disable capacitors for crystal */
  OSC->CR = 0;
    1132:	f8df c0dc 	ldr.w	ip, [pc, #220]	; 1210 <mk20d50_clock_init+0xf0>
void mk20d50_clock_init(void) {
#if !KINETIS_NO_INIT

#if KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE
  uint32_t ratio, frdiv;
  uint32_t ratios[] = { 32, 64, 128, 256, 512, 1024, 1280, 1536 };
    1136:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 *          @p board.c.
 * @todo    This function needs to be more generic.
 *
 * @special
 */
void mk20d50_clock_init(void) {
    1138:	b089      	sub	sp, #36	; 0x24
#if !KINETIS_NO_INIT

#if KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE
  uint32_t ratio, frdiv;
  uint32_t ratios[] = { 32, 64, 128, 256, 512, 1024, 1280, 1536 };
    113a:	466c      	mov	r4, sp
    113c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    113e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
  int ratio_quantity = sizeof(ratios) / sizeof(ratios[0]);
  int i;
#endif /* KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE */

  /* Disable the watchdog */
  WDOG->UNLOCK = 0xC520;
    1142:	f24c 5920 	movw	r9, #50464	; 0xc520
  WDOG->UNLOCK = 0xD928;
    1146:	f64d 1528 	movw	r5, #55592	; 0xd928
void mk20d50_clock_init(void) {
#if !KINETIS_NO_INIT

#if KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE
  uint32_t ratio, frdiv;
  uint32_t ratios[] = { 32, 64, 128, 256, 512, 1024, 1280, 1536 };
    114a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  int ratio_quantity = sizeof(ratios) / sizeof(ratios[0]);
  int i;
#endif /* KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE */

  /* Disable the watchdog */
  WDOG->UNLOCK = 0xC520;
    114e:	f8a6 900e 	strh.w	r9, [r6, #14]
  WDOG->UNLOCK = 0xD928;
    1152:	81f5      	strh	r5, [r6, #14]
  WDOG->STCTRLH &= ~WDOG_STCTRLH_WDOGEN;
    1154:	8833      	ldrh	r3, [r6, #0]
    1156:	f023 0301 	bic.w	r3, r3, #1
    115a:	041b      	lsls	r3, r3, #16

  SIM->SCGC5 |= SIM_SCGC5_PORTA |
    115c:	f241 0238 	movw	r2, #4152	; 0x1038
#endif /* KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE */

  /* Disable the watchdog */
  WDOG->UNLOCK = 0xC520;
  WDOG->UNLOCK = 0xD928;
  WDOG->STCTRLH &= ~WDOG_STCTRLH_WDOGEN;
    1160:	0c1b      	lsrs	r3, r3, #16
    1162:	8033      	strh	r3, [r6, #0]

  SIM->SCGC5 |= SIM_SCGC5_PORTA |
    1164:	f858 3002 	ldr.w	r3, [r8, r2]
    1168:	f443 5378 	orr.w	r3, r3, #15872	; 0x3e00
    116c:	f848 3002 	str.w	r3, [r8, r2]
#endif /* KINETIS_MCG_MODE == KINETIS_MCG_MODE_FEI */

#if KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE

  /* EXTAL0 and XTAL0 */
  PORTA->PCR[18] = 0;
    1170:	2300      	movs	r3, #0
  /* TODO: need to add more flexible calculation, specially regarding
   *       divisors which may not be available depending on the XTAL
   *       frequency, which would required other registers to be modified.
   */
  /* Enable OSC, low power mode */
  MCG->C2 = MCG_C2_LOCRE0 | MCG_C2_EREFS0;
    1172:	2284      	movs	r2, #132	; 0x84
#endif /* KINETIS_MCG_MODE == KINETIS_MCG_MODE_FEI */

#if KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE

  /* EXTAL0 and XTAL0 */
  PORTA->PCR[18] = 0;
    1174:	f8ce 3048 	str.w	r3, [lr, #72]	; 0x48
  PORTA->PCR[19] = 0;
    1178:	f8ce 304c 	str.w	r3, [lr, #76]	; 0x4c
  /*
   * Start in FEI mode
   */

  /* Disable capacitors for crystal */
  OSC->CR = 0;
    117c:	f88c 3000 	strb.w	r3, [ip]
  /* TODO: need to add more flexible calculation, specially regarding
   *       divisors which may not be available depending on the XTAL
   *       frequency, which would required other registers to be modified.
   */
  /* Enable OSC, low power mode */
  MCG->C2 = MCG_C2_LOCRE0 | MCG_C2_EREFS0;
    1180:	707a      	strb	r2, [r7, #1]
  if (KINETIS_XTAL_FREQUENCY > 8000000)
    MCG->C2 |= MCG_C2_RANGE0(2);
  else
    MCG->C2 |= MCG_C2_RANGE0(1);
    1182:	787a      	ldrb	r2, [r7, #1]
    1184:	f042 0210 	orr.w	r2, r2, #16
    1188:	707a      	strb	r2, [r7, #1]
    118a:	f1ad 0204 	sub.w	r2, sp, #4

  frdiv = 7;
  ratio = KINETIS_XTAL_FREQUENCY / 31250;
  for (i = 0; i < ratio_quantity; ++i) {
    if (ratio == ratios[i]) {
    118e:	f852 1f04 	ldr.w	r1, [r2, #4]!
    1192:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
    1196:	d02b      	beq.n	11f0 <mk20d50_clock_init+0xd0>
  else
    MCG->C2 |= MCG_C2_RANGE0(1);

  frdiv = 7;
  ratio = KINETIS_XTAL_FREQUENCY / 31250;
  for (i = 0; i < ratio_quantity; ++i) {
    1198:	3301      	adds	r3, #1
    119a:	2b08      	cmp	r3, #8
    119c:	d1f7      	bne.n	118e <mk20d50_clock_init+0x6e>
    119e:	23b8      	movs	r3, #184	; 0xb8
      break;
    }
  }

  /* Switch to crystal as clock source, FLL input of 31.25 KHz */
  MCG->C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv);
    11a0:	4a18      	ldr	r2, [pc, #96]	; (1204 <mk20d50_clock_init+0xe4>)
    11a2:	7013      	strb	r3, [r2, #0]

  /* Wait for crystal oscillator to begin */
  while (!(MCG->S & MCG_S_OSCINIT0));
    11a4:	7993      	ldrb	r3, [r2, #6]
    11a6:	079d      	lsls	r5, r3, #30
    11a8:	d5fc      	bpl.n	11a4 <mk20d50_clock_init+0x84>

  /* Wait for the FLL to use the oscillator */
  while (MCG->S & MCG_S_IREFST);
    11aa:	4a16      	ldr	r2, [pc, #88]	; (1204 <mk20d50_clock_init+0xe4>)
    11ac:	7993      	ldrb	r3, [r2, #6]
    11ae:	06dc      	lsls	r4, r3, #27
    11b0:	d4fc      	bmi.n	11ac <mk20d50_clock_init+0x8c>

  /* Wait for the MCGOUTCLK to use the oscillator */
  while ((MCG->S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2));
    11b2:	4914      	ldr	r1, [pc, #80]	; (1204 <mk20d50_clock_init+0xe4>)
    11b4:	798b      	ldrb	r3, [r1, #6]
    11b6:	4a13      	ldr	r2, [pc, #76]	; (1204 <mk20d50_clock_init+0xe4>)
    11b8:	f003 030c 	and.w	r3, r3, #12
    11bc:	2b08      	cmp	r3, #8
    11be:	d1f9      	bne.n	11b4 <mk20d50_clock_init+0x94>
  /*
   * Now in FBE mode
   */

  /* Config PLL input for 2 MHz */
  MCG->C5 = MCG_C5_PRDIV0((KINETIS_XTAL_FREQUENCY / 2000000) - 1);
    11c0:	2103      	movs	r1, #3

  /* Config PLL for 96 MHz output */
  MCG->C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0);
    11c2:	2340      	movs	r3, #64	; 0x40
  /*
   * Now in FBE mode
   */

  /* Config PLL input for 2 MHz */
  MCG->C5 = MCG_C5_PRDIV0((KINETIS_XTAL_FREQUENCY / 2000000) - 1);
    11c4:	7111      	strb	r1, [r2, #4]

  /* Config PLL for 96 MHz output */
  MCG->C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0);

  /* Wait for PLL to start using crystal as its input */
  while (!(MCG->S & MCG_S_PLLST));
    11c6:	4611      	mov	r1, r2

  /* Config PLL input for 2 MHz */
  MCG->C5 = MCG_C5_PRDIV0((KINETIS_XTAL_FREQUENCY / 2000000) - 1);

  /* Config PLL for 96 MHz output */
  MCG->C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0);
    11c8:	7153      	strb	r3, [r2, #5]

  /* Wait for PLL to start using crystal as its input */
  while (!(MCG->S & MCG_S_PLLST));
    11ca:	798b      	ldrb	r3, [r1, #6]
    11cc:	0698      	lsls	r0, r3, #26
    11ce:	d5fc      	bpl.n	11ca <mk20d50_clock_init+0xaa>

  /* Wait for PLL to lock */
  while (!(MCG->S & MCG_S_LOCK0));
    11d0:	490c      	ldr	r1, [pc, #48]	; (1204 <mk20d50_clock_init+0xe4>)
    11d2:	798a      	ldrb	r2, [r1, #6]
    11d4:	4b0b      	ldr	r3, [pc, #44]	; (1204 <mk20d50_clock_init+0xe4>)
    11d6:	0652      	lsls	r2, r2, #25
    11d8:	d5fb      	bpl.n	11d2 <mk20d50_clock_init+0xb2>
  /*
   * Now in PBE mode
   */

  /* Switch to PLL as clock source */
  MCG->C1 = MCG_C1_CLKS(0);
    11da:	2200      	movs	r2, #0
    11dc:	701a      	strb	r2, [r3, #0]

  /* Wait for PLL clock to be used */
  while ((MCG->S & MCG_S_CLKST_MASK) != MCG_S_CLKST_PLL);
    11de:	461a      	mov	r2, r3
    11e0:	7993      	ldrb	r3, [r2, #6]
    11e2:	f003 030c 	and.w	r3, r3, #12
    11e6:	2b0c      	cmp	r3, #12
    11e8:	d1fa      	bne.n	11e0 <mk20d50_clock_init+0xc0>
   * Now in PEE mode
   */
#endif /* KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE */

#endif /* !KINETIS_NO_INIT */
}
    11ea:	b009      	add	sp, #36	; 0x24
    11ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    11f0:	00db      	lsls	r3, r3, #3
    11f2:	f003 0338 	and.w	r3, r3, #56	; 0x38
    11f6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  frdiv = 7;
  ratio = KINETIS_XTAL_FREQUENCY / 31250;
  for (i = 0; i < ratio_quantity; ++i) {
    if (ratio == ratios[i]) {
      frdiv = i;
      break;
    11fa:	e7d1      	b.n	11a0 <mk20d50_clock_init+0x80>
    11fc:	00001d40 	.word	0x00001d40
    1200:	40052000 	.word	0x40052000
    1204:	40064000 	.word	0x40064000
    1208:	40047000 	.word	0x40047000
    120c:	40049000 	.word	0x40049000
    1210:	40065000 	.word	0x40065000
    1214:	f3af 8000 	nop.w
    1218:	f3af 8000 	nop.w
    121c:	f3af 8000 	nop.w

00001220 <_pal_lld_setpadmode>:
  PORT_TypeDef *portcfg = NULL;

  chDbgAssert(pad <= 31, "pal_lld_setpadmode() #1, invalid pad");

  if (mode == PAL_MODE_OUTPUT_PUSHPULL)
    port->PDDR |= ((uint32_t) 1 << pad);
    1220:	2301      	movs	r3, #1

  PORT_TypeDef *portcfg = NULL;

  chDbgAssert(pad <= 31, "pal_lld_setpadmode() #1, invalid pad");

  if (mode == PAL_MODE_OUTPUT_PUSHPULL)
    1222:	2a06      	cmp	r2, #6
 *
 * @notapi
 */
void _pal_lld_setpadmode(ioportid_t port,
                         uint8_t pad,
                         iomode_t mode) {
    1224:	b430      	push	{r4, r5}
  PORT_TypeDef *portcfg = NULL;

  chDbgAssert(pad <= 31, "pal_lld_setpadmode() #1, invalid pad");

  if (mode == PAL_MODE_OUTPUT_PUSHPULL)
    port->PDDR |= ((uint32_t) 1 << pad);
    1226:	fa03 f301 	lsl.w	r3, r3, r1
    122a:	6944      	ldr	r4, [r0, #20]
  else
    port->PDDR &= ~((uint32_t) 1 << pad);

  if (port == IOPORT1)
    122c:	4d36      	ldr	r5, [pc, #216]	; (1308 <_pal_lld_setpadmode+0xe8>)

  PORT_TypeDef *portcfg = NULL;

  chDbgAssert(pad <= 31, "pal_lld_setpadmode() #1, invalid pad");

  if (mode == PAL_MODE_OUTPUT_PUSHPULL)
    122e:	d026      	beq.n	127e <_pal_lld_setpadmode+0x5e>
    port->PDDR |= ((uint32_t) 1 << pad);
  else
    port->PDDR &= ~((uint32_t) 1 << pad);
    1230:	ea24 0303 	bic.w	r3, r4, r3

  if (port == IOPORT1)
    1234:	42a8      	cmp	r0, r5
  chDbgAssert(pad <= 31, "pal_lld_setpadmode() #1, invalid pad");

  if (mode == PAL_MODE_OUTPUT_PUSHPULL)
    port->PDDR |= ((uint32_t) 1 << pad);
  else
    port->PDDR &= ~((uint32_t) 1 << pad);
    1236:	6143      	str	r3, [r0, #20]

  if (port == IOPORT1)
    1238:	d05f      	beq.n	12fa <_pal_lld_setpadmode+0xda>
    portcfg = PORTA;
  else if (port == IOPORT2)
    123a:	4b34      	ldr	r3, [pc, #208]	; (130c <_pal_lld_setpadmode+0xec>)
    123c:	4298      	cmp	r0, r3
    123e:	d058      	beq.n	12f2 <_pal_lld_setpadmode+0xd2>
    portcfg = PORTB;
  else if (port == IOPORT3)
    1240:	4b33      	ldr	r3, [pc, #204]	; (1310 <_pal_lld_setpadmode+0xf0>)
    1242:	4298      	cmp	r0, r3
    1244:	d057      	beq.n	12f6 <_pal_lld_setpadmode+0xd6>
    portcfg = PORTC;
  else if (port == IOPORT4)
    1246:	3340      	adds	r3, #64	; 0x40
    1248:	4298      	cmp	r0, r3
    124a:	d058      	beq.n	12fe <_pal_lld_setpadmode+0xde>
    portcfg = PORTD;
  else if (port == IOPORT5)
    124c:	4c31      	ldr	r4, [pc, #196]	; (1314 <_pal_lld_setpadmode+0xf4>)
    portcfg = PORTE;
    124e:	4b32      	ldr	r3, [pc, #200]	; (1318 <_pal_lld_setpadmode+0xf8>)
    1250:	42a0      	cmp	r0, r4
    1252:	bf0c      	ite	eq
    1254:	4618      	moveq	r0, r3
    1256:	2000      	movne	r0, #0

  chDbgAssert(portcfg != NULL, "pal_lld_setpadmode() #2, invalid port");

  switch (mode) {
    1258:	2a10      	cmp	r2, #16
    125a:	d80e      	bhi.n	127a <_pal_lld_setpadmode+0x5a>
    125c:	e8df f002 	tbb	[pc, r2]
    1260:	3a173617 	.word	0x3a173617
    1264:	4417363f 	.word	0x4417363f
    1268:	1d170d0d 	.word	0x1d170d0d
    126c:	2c092722 	.word	0x2c092722
    1270:	31          	.byte	0x31
    1271:	00          	.byte	0x00
    break;
  case PAL_MODE_ALTERNATIVE_4:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(4);
    break;
  case PAL_MODE_ALTERNATIVE_5:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(5);
    1272:	f44f 63a0 	mov.w	r3, #1280	; 0x500
    1276:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
    break;
  case PAL_MODE_ALTERNATIVE_7:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(7);
    break;
  }
}
    127a:	bc30      	pop	{r4, r5}
    127c:	4770      	bx	lr
  PORT_TypeDef *portcfg = NULL;

  chDbgAssert(pad <= 31, "pal_lld_setpadmode() #1, invalid pad");

  if (mode == PAL_MODE_OUTPUT_PUSHPULL)
    port->PDDR |= ((uint32_t) 1 << pad);
    127e:	4323      	orrs	r3, r4
  else
    port->PDDR &= ~((uint32_t) 1 << pad);

  if (port == IOPORT1)
    1280:	42a8      	cmp	r0, r5
  PORT_TypeDef *portcfg = NULL;

  chDbgAssert(pad <= 31, "pal_lld_setpadmode() #1, invalid pad");

  if (mode == PAL_MODE_OUTPUT_PUSHPULL)
    port->PDDR |= ((uint32_t) 1 << pad);
    1282:	6143      	str	r3, [r0, #20]
  else
    port->PDDR &= ~((uint32_t) 1 << pad);

  if (port == IOPORT1)
    1284:	d03d      	beq.n	1302 <_pal_lld_setpadmode+0xe2>
    portcfg = PORTA;
  else if (port == IOPORT2)
    1286:	4b21      	ldr	r3, [pc, #132]	; (130c <_pal_lld_setpadmode+0xec>)
    1288:	4298      	cmp	r0, r3
    128a:	d1d9      	bne.n	1240 <_pal_lld_setpadmode+0x20>
    portcfg = PORTB;
    128c:	4823      	ldr	r0, [pc, #140]	; (131c <_pal_lld_setpadmode+0xfc>)
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_ANALOG:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(0);
    break;
  case PAL_MODE_ALTERNATIVE_1:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1);
    128e:	f44f 7380 	mov.w	r3, #256	; 0x100
    1292:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
    break;
  case PAL_MODE_ALTERNATIVE_7:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(7);
    break;
  }
}
    1296:	bc30      	pop	{r4, r5}
    1298:	4770      	bx	lr
    break;
  case PAL_MODE_ALTERNATIVE_1:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1);
    break;
  case PAL_MODE_ALTERNATIVE_2:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(2);
    129a:	f44f 7300 	mov.w	r3, #512	; 0x200
    129e:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
    break;
    12a2:	e7ea      	b.n	127a <_pal_lld_setpadmode+0x5a>
  case PAL_MODE_ALTERNATIVE_3:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(3);
    12a4:	f44f 7340 	mov.w	r3, #768	; 0x300
    12a8:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
    break;
    12ac:	e7e5      	b.n	127a <_pal_lld_setpadmode+0x5a>
  case PAL_MODE_ALTERNATIVE_4:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(4);
    12ae:	f44f 6380 	mov.w	r3, #1024	; 0x400
    12b2:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
    break;
    12b6:	e7e0      	b.n	127a <_pal_lld_setpadmode+0x5a>
  case PAL_MODE_ALTERNATIVE_5:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(5);
    break;
  case PAL_MODE_ALTERNATIVE_6:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(6);
    12b8:	f44f 63c0 	mov.w	r3, #1536	; 0x600
    12bc:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
    break;
    12c0:	e7db      	b.n	127a <_pal_lld_setpadmode+0x5a>
  case PAL_MODE_ALTERNATIVE_7:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(7);
    12c2:	f44f 63e0 	mov.w	r3, #1792	; 0x700
    12c6:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
    break;
    12ca:	e7d6      	b.n	127a <_pal_lld_setpadmode+0x5a>
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
                        PORTx_PCRn_PE;
      break;
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_ANALOG:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(0);
    12cc:	2300      	movs	r3, #0
    12ce:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
    break;
    12d2:	e7d2      	b.n	127a <_pal_lld_setpadmode+0x5a>
  case PAL_MODE_OUTPUT_OPENDRAIN:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
                        PORTx_PCRn_ODE;
    break;
  case PAL_MODE_INPUT_PULLUP:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
    12d4:	f240 1303 	movw	r3, #259	; 0x103
    12d8:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
                        PORTx_PCRn_PE |
                        PORTx_PCRn_PS;
      break;
    12dc:	e7cd      	b.n	127a <_pal_lld_setpadmode+0x5a>
  case PAL_MODE_INPUT_PULLDOWN:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
    12de:	f44f 7381 	mov.w	r3, #258	; 0x102
    12e2:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
                        PORTx_PCRn_PE;
      break;
    12e6:	e7c8      	b.n	127a <_pal_lld_setpadmode+0x5a>
  case PAL_MODE_INPUT:
  case PAL_MODE_OUTPUT_PUSHPULL:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1);
    break;
  case PAL_MODE_OUTPUT_OPENDRAIN:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
    12e8:	f44f 7390 	mov.w	r3, #288	; 0x120
    12ec:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
                        PORTx_PCRn_ODE;
    break;
    12f0:	e7c3      	b.n	127a <_pal_lld_setpadmode+0x5a>
    port->PDDR &= ~((uint32_t) 1 << pad);

  if (port == IOPORT1)
    portcfg = PORTA;
  else if (port == IOPORT2)
    portcfg = PORTB;
    12f2:	480a      	ldr	r0, [pc, #40]	; (131c <_pal_lld_setpadmode+0xfc>)
    12f4:	e7b0      	b.n	1258 <_pal_lld_setpadmode+0x38>
  else if (port == IOPORT3)
    portcfg = PORTC;
    12f6:	480a      	ldr	r0, [pc, #40]	; (1320 <_pal_lld_setpadmode+0x100>)
    12f8:	e7ae      	b.n	1258 <_pal_lld_setpadmode+0x38>
    port->PDDR |= ((uint32_t) 1 << pad);
  else
    port->PDDR &= ~((uint32_t) 1 << pad);

  if (port == IOPORT1)
    portcfg = PORTA;
    12fa:	480a      	ldr	r0, [pc, #40]	; (1324 <_pal_lld_setpadmode+0x104>)
    12fc:	e7ac      	b.n	1258 <_pal_lld_setpadmode+0x38>
  else if (port == IOPORT2)
    portcfg = PORTB;
  else if (port == IOPORT3)
    portcfg = PORTC;
  else if (port == IOPORT4)
    portcfg = PORTD;
    12fe:	480a      	ldr	r0, [pc, #40]	; (1328 <_pal_lld_setpadmode+0x108>)
    1300:	e7aa      	b.n	1258 <_pal_lld_setpadmode+0x38>
    port->PDDR |= ((uint32_t) 1 << pad);
  else
    port->PDDR &= ~((uint32_t) 1 << pad);

  if (port == IOPORT1)
    portcfg = PORTA;
    1302:	4808      	ldr	r0, [pc, #32]	; (1324 <_pal_lld_setpadmode+0x104>)
    1304:	e7c3      	b.n	128e <_pal_lld_setpadmode+0x6e>
    1306:	bf00      	nop
    1308:	400ff000 	.word	0x400ff000
    130c:	400ff040 	.word	0x400ff040
    1310:	400ff080 	.word	0x400ff080
    1314:	400ff100 	.word	0x400ff100
    1318:	4004d000 	.word	0x4004d000
    131c:	4004a000 	.word	0x4004a000
    1320:	4004b000 	.word	0x4004b000
    1324:	40049000 	.word	0x40049000
    1328:	4004c000 	.word	0x4004c000
    132c:	f3af 8000 	nop.w

00001330 <_pal_lld_init>:
void _pal_lld_init(const PALConfig *config) {

  int i, j;

  /* Enable clocking on all Ports */
  SIM->SCGC5 |= SIM_SCGC5_PORTA |
    1330:	490c      	ldr	r1, [pc, #48]	; (1364 <_pal_lld_init+0x34>)
    1332:	f241 0238 	movw	r2, #4152	; 0x1038
 *
 * @param[in] config    the Kinetis ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    1336:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  int i, j;

  /* Enable clocking on all Ports */
  SIM->SCGC5 |= SIM_SCGC5_PORTA |
    1338:	588b      	ldr	r3, [r1, r2]
    133a:	f443 5378 	orr.w	r3, r3, #15872	; 0x3e00
    133e:	508b      	str	r3, [r1, r2]
    1340:	4606      	mov	r6, r0
    1342:	f500 7725 	add.w	r7, r0, #660	; 0x294
 *
 * @param[in] config    the Kinetis ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    1346:	4635      	mov	r5, r6
    1348:	2400      	movs	r4, #0
                SIM_SCGC5_PORTE;

  /* Initial PORT and GPIO setup */
  for (i = 0; i < TOTAL_PORTS; i++) {
    for (j = 0; j < PADS_PER_PORT; j++) {
      pal_lld_setpadmode(config->ports[i].port,
    134a:	b2e1      	uxtb	r1, r4
    134c:	6830      	ldr	r0, [r6, #0]
    134e:	f855 2f04 	ldr.w	r2, [r5, #4]!
                SIM_SCGC5_PORTD |
                SIM_SCGC5_PORTE;

  /* Initial PORT and GPIO setup */
  for (i = 0; i < TOTAL_PORTS; i++) {
    for (j = 0; j < PADS_PER_PORT; j++) {
    1352:	3401      	adds	r4, #1
      pal_lld_setpadmode(config->ports[i].port,
    1354:	f7ff ff64 	bl	1220 <_pal_lld_setpadmode>
                SIM_SCGC5_PORTD |
                SIM_SCGC5_PORTE;

  /* Initial PORT and GPIO setup */
  for (i = 0; i < TOTAL_PORTS; i++) {
    for (j = 0; j < PADS_PER_PORT; j++) {
    1358:	2c20      	cmp	r4, #32
    135a:	d1f6      	bne.n	134a <_pal_lld_init+0x1a>
    135c:	3684      	adds	r6, #132	; 0x84
                SIM_SCGC5_PORTC |
                SIM_SCGC5_PORTD |
                SIM_SCGC5_PORTE;

  /* Initial PORT and GPIO setup */
  for (i = 0; i < TOTAL_PORTS; i++) {
    135e:	42be      	cmp	r6, r7
    1360:	d1f1      	bne.n	1346 <_pal_lld_init+0x16>
    1362:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1364:	40047000 	.word	0x40047000
    1368:	f3af 8000 	nop.w
    136c:	f3af 8000 	nop.w

00001370 <notify1>:
/**
 * @brief   Driver output notification.
 */
#if KINETIS_SERIAL_USE_UART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp)
{
    1370:	b538      	push	{r3, r4, r5, lr}

/**
 * @brief   Attempts a TX preload
 */
static void preload(SerialDriver *sdp) {
  UART_TypeDef *u = sdp->uart;
    1372:	4d0c      	ldr	r5, [pc, #48]	; (13a4 <notify1+0x34>)
    1374:	6f6c      	ldr	r4, [r5, #116]	; 0x74

  if (u->S1 & UARTx_S1_TDRE) {
    1376:	7923      	ldrb	r3, [r4, #4]
    1378:	061b      	lsls	r3, r3, #24
    137a:	d400      	bmi.n	137e <notify1+0xe>
    137c:	bd38      	pop	{r3, r4, r5, pc}
    msg_t b = oqGetI(&sdp->oqueue);
    137e:	f105 0030 	add.w	r0, r5, #48	; 0x30
    1382:	f7ff fced 	bl	d60 <chOQGetI>
    if (b < Q_OK) {
    1386:	2800      	cmp	r0, #0
    1388:	db06      	blt.n	1398 <notify1+0x28>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      return;
    }
    u->D = b;
    138a:	b2c0      	uxtb	r0, r0
    138c:	71e0      	strb	r0, [r4, #7]
    u->C2 |= UARTx_C2_TIE;
    138e:	78e3      	ldrb	r3, [r4, #3]
    1390:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    1394:	70e3      	strb	r3, [r4, #3]
    1396:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
    1398:	1d28      	adds	r0, r5, #4
    139a:	2108      	movs	r1, #8
#if KINETIS_SERIAL_USE_UART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp)
{
  (void)qp;
  preload(&SD1);
}
    139c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    13a0:	f7ff bbee 	b.w	b80 <chEvtBroadcastFlagsI>
    13a4:	1fffe780 	.word	0x1fffe780
    13a8:	f3af 8000 	nop.w
    13ac:	f3af 8000 	nop.w

000013b0 <Vector80>:
 *   UART1_Error is Vector8C
 *   UART2_Error is Vector94
 */

#if KINETIS_SERIAL_USE_UART0 || defined(__DOXYGEN__)
OSAL_IRQ_HANDLER(Vector80) {
    13b0:	b570      	push	{r4, r5, r6, lr}
 *
 * @param[in] u         pointer to an UART I/O block
 * @param[in] sdp       communication channel associated to the UART
 */
static void serve_interrupt(SerialDriver *sdp) {
  UART_TypeDef *u = sdp->uart;
    13b2:	4823      	ldr	r0, [pc, #140]	; (1440 <Vector80+0x90>)
    13b4:	6f45      	ldr	r5, [r0, #116]	; 0x74
  uint8_t s1 = u->S1;
    13b6:	792c      	ldrb	r4, [r5, #4]
    13b8:	b2e4      	uxtb	r4, r4

  if (s1 & UARTx_S1_RDRF) {
    13ba:	06a2      	lsls	r2, r4, #26
    13bc:	d50d      	bpl.n	13da <Vector80+0x2a>
    13be:	2320      	movs	r3, #32
    13c0:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
    13c4:	6943      	ldr	r3, [r0, #20]
    osalSysLockFromISR();
    if (iqIsEmptyI(&sdp->iqueue))
    13c6:	b173      	cbz	r3, 13e6 <Vector80+0x36>
      chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    if (iqPutI(&sdp->iqueue, u->D) < Q_OK)
    13c8:	79e9      	ldrb	r1, [r5, #7]
    13ca:	481e      	ldr	r0, [pc, #120]	; (1444 <Vector80+0x94>)
    13cc:	f7ff fc00 	bl	bd0 <chIQPutI>
    13d0:	2800      	cmp	r0, #0
    13d2:	db12      	blt.n	13fa <Vector80+0x4a>
    13d4:	2300      	movs	r3, #0
    13d6:	f383 8811 	msr	BASEPRI, r3
      chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    osalSysUnlockFromISR();
  }

  if (s1 & UARTx_S1_TDRE) {
    13da:	0623      	lsls	r3, r4, #24
    13dc:	d412      	bmi.n	1404 <Vector80+0x54>
OSAL_IRQ_HANDLER(Vector80) {

  OSAL_IRQ_PROLOGUE();
  serve_interrupt(&SD1);
  OSAL_IRQ_EPILOGUE();
}
    13de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
#if KINETIS_SERIAL_USE_UART0 || defined(__DOXYGEN__)
OSAL_IRQ_HANDLER(Vector80) {

  OSAL_IRQ_PROLOGUE();
  serve_interrupt(&SD1);
  OSAL_IRQ_EPILOGUE();
    13e2:	f7ff bd8d 	b.w	f00 <_port_irq_epilogue>
    13e6:	3004      	adds	r0, #4
    13e8:	2104      	movs	r1, #4
    13ea:	f7ff fbc9 	bl	b80 <chEvtBroadcastFlagsI>

  if (s1 & UARTx_S1_RDRF) {
    osalSysLockFromISR();
    if (iqIsEmptyI(&sdp->iqueue))
      chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    if (iqPutI(&sdp->iqueue, u->D) < Q_OK)
    13ee:	79e9      	ldrb	r1, [r5, #7]
    13f0:	4814      	ldr	r0, [pc, #80]	; (1444 <Vector80+0x94>)
    13f2:	f7ff fbed 	bl	bd0 <chIQPutI>
    13f6:	2800      	cmp	r0, #0
    13f8:	daec      	bge.n	13d4 <Vector80+0x24>
    13fa:	4813      	ldr	r0, [pc, #76]	; (1448 <Vector80+0x98>)
    13fc:	2180      	movs	r1, #128	; 0x80
    13fe:	f7ff fbbf 	bl	b80 <chEvtBroadcastFlagsI>
    1402:	e7e7      	b.n	13d4 <Vector80+0x24>
    1404:	2620      	movs	r6, #32
    1406:	f386 8811 	msr	BASEPRI, r6

  if (s1 & UARTx_S1_TDRE) {
    msg_t b;

    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    140a:	4810      	ldr	r0, [pc, #64]	; (144c <Vector80+0x9c>)
    140c:	f7ff fca8 	bl	d60 <chOQGetI>
    1410:	2400      	movs	r4, #0
    1412:	f384 8811 	msr	BASEPRI, r4
    osalSysUnlockFromISR();

    if (b < Q_OK) {
    1416:	42a0      	cmp	r0, r4
    1418:	db05      	blt.n	1426 <Vector80+0x76>
      osalSysLockFromISR();
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      osalSysUnlockFromISR();
      u->C2 &= ~UARTx_C2_TIE;
    } else {
       u->D = b;
    141a:	b2c0      	uxtb	r0, r0
    141c:	71e8      	strb	r0, [r5, #7]
OSAL_IRQ_HANDLER(Vector80) {

  OSAL_IRQ_PROLOGUE();
  serve_interrupt(&SD1);
  OSAL_IRQ_EPILOGUE();
}
    141e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
#if KINETIS_SERIAL_USE_UART0 || defined(__DOXYGEN__)
OSAL_IRQ_HANDLER(Vector80) {

  OSAL_IRQ_PROLOGUE();
  serve_interrupt(&SD1);
  OSAL_IRQ_EPILOGUE();
    1422:	f7ff bd6d 	b.w	f00 <_port_irq_epilogue>
    1426:	f386 8811 	msr	BASEPRI, r6
    142a:	4807      	ldr	r0, [pc, #28]	; (1448 <Vector80+0x98>)
    142c:	2108      	movs	r1, #8
    142e:	f7ff fba7 	bl	b80 <chEvtBroadcastFlagsI>
    1432:	f384 8811 	msr	BASEPRI, r4

    if (b < Q_OK) {
      osalSysLockFromISR();
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      osalSysUnlockFromISR();
      u->C2 &= ~UARTx_C2_TIE;
    1436:	78eb      	ldrb	r3, [r5, #3]
    1438:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    143c:	70eb      	strb	r3, [r5, #3]
    143e:	e7ce      	b.n	13de <Vector80+0x2e>
    1440:	1fffe780 	.word	0x1fffe780
    1444:	1fffe78c 	.word	0x1fffe78c
    1448:	1fffe784 	.word	0x1fffe784
    144c:	1fffe7b0 	.word	0x1fffe7b0

00001450 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
    1450:	b510      	push	{r4, lr}

#if KINETIS_SERIAL_USE_UART0
  /* Driver initialization.*/
  sdObjectInit(&SD1, NULL, notify1);
    1452:	4c04      	ldr	r4, [pc, #16]	; (1464 <sd_lld_init+0x14>)
    1454:	4a04      	ldr	r2, [pc, #16]	; (1468 <sd_lld_init+0x18>)
    1456:	4620      	mov	r0, r4
    1458:	2100      	movs	r1, #0
    145a:	f7ff fe01 	bl	1060 <sdObjectInit>
  SD1.uart = UART0;
    145e:	4b03      	ldr	r3, [pc, #12]	; (146c <sd_lld_init+0x1c>)
    1460:	6763      	str	r3, [r4, #116]	; 0x74
    1462:	bd10      	pop	{r4, pc}
    1464:	1fffe780 	.word	0x1fffe780
    1468:	00001371 	.word	0x00001371
    146c:	4006a000 	.word	0x4006a000

00001470 <sd_lld_start>:
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
    1470:	4b1e      	ldr	r3, [pc, #120]	; (14ec <sd_lld_start+0x7c>)

  if (sdp->state == SD_STOP) {
    1472:	6882      	ldr	r2, [r0, #8]
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
    1474:	2900      	cmp	r1, #0
    1476:	bf08      	it	eq
    1478:	4619      	moveq	r1, r3

  if (sdp->state == SD_STOP) {
    147a:	2a01      	cmp	r2, #1
    147c:	d000      	beq.n	1480 <sd_lld_start+0x10>
    147e:	4770      	bx	lr
    /* Enables the peripheral.*/

#if KINETIS_SERIAL_USE_UART0
    if (sdp == &SD1) {
    1480:	4b1b      	ldr	r3, [pc, #108]	; (14f0 <sd_lld_start+0x80>)
    1482:	4298      	cmp	r0, r3
    1484:	d1fb      	bne.n	147e <sd_lld_start+0xe>
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
    1486:	b470      	push	{r4, r5, r6}
  if (sdp->state == SD_STOP) {
    /* Enables the peripheral.*/

#if KINETIS_SERIAL_USE_UART0
    if (sdp == &SD1) {
      SIM->SCGC4 |= SIM_SCGC4_UART0;
    1488:	4d1a      	ldr	r5, [pc, #104]	; (14f4 <sd_lld_start+0x84>)
      configure_uart(sdp->uart, config);
    148a:	6f43      	ldr	r3, [r0, #116]	; 0x74
  if (sdp->state == SD_STOP) {
    /* Enables the peripheral.*/

#if KINETIS_SERIAL_USE_UART0
    if (sdp == &SD1) {
      SIM->SCGC4 |= SIM_SCGC4_UART0;
    148c:	f241 0434 	movw	r4, #4148	; 0x1034
 * @brief   Common UART configuration.
 *
 */
static void configure_uart(UART_TypeDef *uart, const SerialConfig *config)
{
  uint32_t divisor = (KINETIS_SYSCLK_FREQUENCY * 2 + 1) / config->sc_speed;
    1490:	f102 62b7 	add.w	r2, r2, #95944704	; 0x5b80000
  if (sdp->state == SD_STOP) {
    /* Enables the peripheral.*/

#if KINETIS_SERIAL_USE_UART0
    if (sdp == &SD1) {
      SIM->SCGC4 |= SIM_SCGC4_UART0;
    1494:	5928      	ldr	r0, [r5, r4]
    1496:	f440 6080 	orr.w	r0, r0, #1024	; 0x400
    149a:	5128      	str	r0, [r5, r4]
static void configure_uart(UART_TypeDef *uart, const SerialConfig *config)
{
  uint32_t divisor = (KINETIS_SYSCLK_FREQUENCY * 2 + 1) / config->sc_speed;

  /* Disable UART while configuring */
  uart->C2 &= ~(UARTx_C2_RE | UARTx_C2_TE);
    149c:	78d8      	ldrb	r0, [r3, #3]
 * @brief   Common UART configuration.
 *
 */
static void configure_uart(UART_TypeDef *uart, const SerialConfig *config)
{
  uint32_t divisor = (KINETIS_SYSCLK_FREQUENCY * 2 + 1) / config->sc_speed;
    149e:	6809      	ldr	r1, [r1, #0]

  /* Disable UART while configuring */
  uart->C2 &= ~(UARTx_C2_RE | UARTx_C2_TE);
  uart->C1 = 0;
    14a0:	2600      	movs	r6, #0
 * @brief   Common UART configuration.
 *
 */
static void configure_uart(UART_TypeDef *uart, const SerialConfig *config)
{
  uint32_t divisor = (KINETIS_SYSCLK_FREQUENCY * 2 + 1) / config->sc_speed;
    14a2:	f502 4258 	add.w	r2, r2, #55296	; 0xd800
    14a6:	fbb2 f2f1 	udiv	r2, r2, r1

  /* Disable UART while configuring */
  uart->C2 &= ~(UARTx_C2_RE | UARTx_C2_TE);
    14aa:	f000 01f3 	and.w	r1, r0, #243	; 0xf3
    14ae:	70d9      	strb	r1, [r3, #3]
  uart->C1 = 0;
    14b0:	709e      	strb	r6, [r3, #2]

  uart->BDH = UARTx_BDH_SBR(divisor >> 13) | (uart->BDH & ~UARTx_BDH_SBR_MASK);
    14b2:	7819      	ldrb	r1, [r3, #0]
    14b4:	f3c2 3044 	ubfx	r0, r2, #13, #5
    14b8:	f001 01e0 	and.w	r1, r1, #224	; 0xe0
    14bc:	4301      	orrs	r1, r0
  uart->BDL = divisor >> 5;
    14be:	f3c2 1047 	ubfx	r0, r2, #5, #8

  /* Disable UART while configuring */
  uart->C2 &= ~(UARTx_C2_RE | UARTx_C2_TE);
  uart->C1 = 0;

  uart->BDH = UARTx_BDH_SBR(divisor >> 13) | (uart->BDH & ~UARTx_BDH_SBR_MASK);
    14c2:	7019      	strb	r1, [r3, #0]
  uart->BDL = divisor >> 5;
    14c4:	7058      	strb	r0, [r3, #1]
  uart->C4  = UARTx_C4_BRFA(divisor) | (uart->C4 & ~UARTx_C4_BRFA_MASK);
    14c6:	7a99      	ldrb	r1, [r3, #10]
    14c8:	f002 021f 	and.w	r2, r2, #31
    14cc:	f001 01e0 	and.w	r1, r1, #224	; 0xe0
    14d0:	430a      	orrs	r2, r1
    14d2:	729a      	strb	r2, [r3, #10]

  uart->C2 |= UARTx_C2_RE | UARTx_C2_RIE | UARTx_C2_TE;
    14d4:	78da      	ldrb	r2, [r3, #3]
  uart->C3 = UARTx_C3_ORIE | UARTx_C3_NEIE | UARTx_C3_FEIE | UARTx_C3_PEIE;
    14d6:	210f      	movs	r1, #15

  uart->BDH = UARTx_BDH_SBR(divisor >> 13) | (uart->BDH & ~UARTx_BDH_SBR_MASK);
  uart->BDL = divisor >> 5;
  uart->C4  = UARTx_C4_BRFA(divisor) | (uart->C4 & ~UARTx_C4_BRFA_MASK);

  uart->C2 |= UARTx_C2_RE | UARTx_C2_RIE | UARTx_C2_TE;
    14d8:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
    14dc:	70da      	strb	r2, [r3, #3]
  uart->C3 = UARTx_C3_ORIE | UARTx_C3_NEIE | UARTx_C3_FEIE | UARTx_C3_PEIE;
    14de:	7199      	strb	r1, [r3, #6]

#if KINETIS_SERIAL_USE_UART0
    if (sdp == &SD1) {
      SIM->SCGC4 |= SIM_SCGC4_UART0;
      configure_uart(sdp->uart, config);
      nvicEnableVector(UART0Status_IRQn, KINETIS_SERIAL_UART0_PRIORITY);
    14e0:	2010      	movs	r0, #16
    14e2:	210c      	movs	r1, #12
#endif /* KINETIS_SERIAL_USE_UART2 */

  }
  /* Configures the peripheral.*/

}
    14e4:	bc70      	pop	{r4, r5, r6}

#if KINETIS_SERIAL_USE_UART0
    if (sdp == &SD1) {
      SIM->SCGC4 |= SIM_SCGC4_UART0;
      configure_uart(sdp->uart, config);
      nvicEnableVector(UART0Status_IRQn, KINETIS_SERIAL_UART0_PRIORITY);
    14e6:	f7ff bdeb 	b.w	10c0 <nvicEnableVector>
    14ea:	bf00      	nop
    14ec:	00001e30 	.word	0x00001e30
    14f0:	1fffe780 	.word	0x1fffe780
    14f4:	40047000 	.word	0x40047000
    14f8:	f3af 8000 	nop.w
    14fc:	f3af 8000 	nop.w

00001500 <VectorE0>:
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    1500:	4b12      	ldr	r3, [pc, #72]	; (154c <VectorE0+0x4c>)

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    1502:	f04f 32ff 	mov.w	r2, #4294967295
 * @brief   PORTA interrupt handler.
 *
 * @isr
 */
#if defined(KINETIS_PORTA_IRQ_VECTOR) && KINETIS_EXT_PORTA_WIDTH > 0
OSAL_IRQ_HANDLER(KINETIS_PORTA_IRQ_VECTOR) {
    1506:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    150a:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    150e:	4f10      	ldr	r7, [pc, #64]	; (1550 <VectorE0+0x50>)
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    1510:	f8df 8040 	ldr.w	r8, [pc, #64]	; 1554 <VectorE0+0x54>
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    1514:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  for (pin = 0; pin < port_width; pin++) {
    1518:	2400      	movs	r4, #0
    if (isfr & (1 << pin)) {
    151a:	2501      	movs	r5, #1
    151c:	e002      	b.n	1524 <VectorE0+0x24>
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    151e:	3401      	adds	r4, #1
    1520:	2c14      	cmp	r4, #20
    1522:	d00e      	beq.n	1542 <VectorE0+0x42>
    if (isfr & (1 << pin)) {
    1524:	fa05 f304 	lsl.w	r3, r5, r4
    1528:	4233      	tst	r3, r6
    152a:	d0f8      	beq.n	151e <VectorE0+0x1e>
      expchannel_t channel = channel_map[pin];
    152c:	5de1      	ldrb	r1, [r4, r7]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    152e:	f8d8 3004 	ldr.w	r3, [r8, #4]
    1532:	4808      	ldr	r0, [pc, #32]	; (1554 <VectorE0+0x54>)
    1534:	eb03 1301 	add.w	r3, r3, r1, lsl #4
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    1538:	3401      	adds	r4, #1
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    153a:	685b      	ldr	r3, [r3, #4]
    153c:	4798      	blx	r3
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    153e:	2c14      	cmp	r4, #20
    1540:	d1f0      	bne.n	1524 <VectorE0+0x24>
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTA, KINETIS_EXT_PORTA_WIDTH, porta_channel_map);

  OSAL_IRQ_EPILOGUE();
}
    1542:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTA_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTA, KINETIS_EXT_PORTA_WIDTH, porta_channel_map);

  OSAL_IRQ_EPILOGUE();
    1546:	f7ff bcdb 	b.w	f00 <_port_irq_epilogue>
    154a:	bf00      	nop
    154c:	40049000 	.word	0x40049000
    1550:	1fffe82c 	.word	0x1fffe82c
    1554:	1fffe7f8 	.word	0x1fffe7f8
    1558:	f3af 8000 	nop.w
    155c:	f3af 8000 	nop.w

00001560 <VectorE4>:
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    1560:	4b12      	ldr	r3, [pc, #72]	; (15ac <VectorE4+0x4c>)

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    1562:	f04f 32ff 	mov.w	r2, #4294967295
 * @brief   PORTB interrupt handler.
 *
 * @isr
 */
#if defined(KINETIS_PORTB_IRQ_VECTOR) && KINETIS_EXT_PORTB_WIDTH > 0
OSAL_IRQ_HANDLER(KINETIS_PORTB_IRQ_VECTOR) {
    1566:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    156a:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    156e:	4f10      	ldr	r7, [pc, #64]	; (15b0 <VectorE4+0x50>)
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    1570:	f8df 8040 	ldr.w	r8, [pc, #64]	; 15b4 <VectorE4+0x54>
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    1574:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  for (pin = 0; pin < port_width; pin++) {
    1578:	2400      	movs	r4, #0
    if (isfr & (1 << pin)) {
    157a:	2501      	movs	r5, #1
    157c:	e002      	b.n	1584 <VectorE4+0x24>
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    157e:	3401      	adds	r4, #1
    1580:	2c14      	cmp	r4, #20
    1582:	d00e      	beq.n	15a2 <VectorE4+0x42>
    if (isfr & (1 << pin)) {
    1584:	fa05 f304 	lsl.w	r3, r5, r4
    1588:	4233      	tst	r3, r6
    158a:	d0f8      	beq.n	157e <VectorE4+0x1e>
      expchannel_t channel = channel_map[pin];
    158c:	5de1      	ldrb	r1, [r4, r7]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    158e:	f8d8 3004 	ldr.w	r3, [r8, #4]
    1592:	4808      	ldr	r0, [pc, #32]	; (15b4 <VectorE4+0x54>)
    1594:	eb03 1301 	add.w	r3, r3, r1, lsl #4
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    1598:	3401      	adds	r4, #1
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    159a:	685b      	ldr	r3, [r3, #4]
    159c:	4798      	blx	r3
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    159e:	2c14      	cmp	r4, #20
    15a0:	d1f0      	bne.n	1584 <VectorE4+0x24>
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTB, KINETIS_EXT_PORTB_WIDTH, portb_channel_map);

  OSAL_IRQ_EPILOGUE();
}
    15a2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTB_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTB, KINETIS_EXT_PORTB_WIDTH, portb_channel_map);

  OSAL_IRQ_EPILOGUE();
    15a6:	f7ff bcab 	b.w	f00 <_port_irq_epilogue>
    15aa:	bf00      	nop
    15ac:	4004a000 	.word	0x4004a000
    15b0:	1fffe818 	.word	0x1fffe818
    15b4:	1fffe7f8 	.word	0x1fffe7f8
    15b8:	f3af 8000 	nop.w
    15bc:	f3af 8000 	nop.w

000015c0 <VectorE8>:
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    15c0:	4b12      	ldr	r3, [pc, #72]	; (160c <VectorE8+0x4c>)

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    15c2:	f04f 32ff 	mov.w	r2, #4294967295
 * @brief   PORTC interrupt handler.
 *
 * @isr
 */
#if defined(KINETIS_PORTC_IRQ_VECTOR) && KINETIS_EXT_PORTC_WIDTH > 0
OSAL_IRQ_HANDLER(KINETIS_PORTC_IRQ_VECTOR) {
    15c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    15ca:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    15ce:	4f10      	ldr	r7, [pc, #64]	; (1610 <VectorE8+0x50>)
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    15d0:	f8df 8040 	ldr.w	r8, [pc, #64]	; 1614 <VectorE8+0x54>
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    15d4:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  for (pin = 0; pin < port_width; pin++) {
    15d8:	2400      	movs	r4, #0
    if (isfr & (1 << pin)) {
    15da:	2501      	movs	r5, #1
    15dc:	e002      	b.n	15e4 <VectorE8+0x24>
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    15de:	3401      	adds	r4, #1
    15e0:	2c0c      	cmp	r4, #12
    15e2:	d00e      	beq.n	1602 <VectorE8+0x42>
    if (isfr & (1 << pin)) {
    15e4:	fa05 f304 	lsl.w	r3, r5, r4
    15e8:	4233      	tst	r3, r6
    15ea:	d0f8      	beq.n	15de <VectorE8+0x1e>
      expchannel_t channel = channel_map[pin];
    15ec:	5de1      	ldrb	r1, [r4, r7]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    15ee:	f8d8 3004 	ldr.w	r3, [r8, #4]
    15f2:	4808      	ldr	r0, [pc, #32]	; (1614 <VectorE8+0x54>)
    15f4:	eb03 1301 	add.w	r3, r3, r1, lsl #4
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    15f8:	3401      	adds	r4, #1
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    15fa:	685b      	ldr	r3, [r3, #4]
    15fc:	4798      	blx	r3
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    15fe:	2c0c      	cmp	r4, #12
    1600:	d1f0      	bne.n	15e4 <VectorE8+0x24>
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTC, KINETIS_EXT_PORTC_WIDTH, portc_channel_map);

  OSAL_IRQ_EPILOGUE();
}
    1602:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTC_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTC, KINETIS_EXT_PORTC_WIDTH, portc_channel_map);

  OSAL_IRQ_EPILOGUE();
    1606:	f7ff bc7b 	b.w	f00 <_port_irq_epilogue>
    160a:	bf00      	nop
    160c:	4004b000 	.word	0x4004b000
    1610:	1fffe80c 	.word	0x1fffe80c
    1614:	1fffe7f8 	.word	0x1fffe7f8
    1618:	f3af 8000 	nop.w
    161c:	f3af 8000 	nop.w

00001620 <VectorEC>:
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    1620:	4b12      	ldr	r3, [pc, #72]	; (166c <VectorEC+0x4c>)

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    1622:	f04f 32ff 	mov.w	r2, #4294967295
 * @brief   PORTD interrupt handler.
 *
 * @isr
 */
#if defined(KINETIS_PORTD_IRQ_VECTOR) && KINETIS_EXT_PORTD_WIDTH > 0
OSAL_IRQ_HANDLER(KINETIS_PORTD_IRQ_VECTOR) {
    1626:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    162a:	f8d3 60a0 	ldr.w	r6, [r3, #160]	; 0xa0
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    162e:	4f10      	ldr	r7, [pc, #64]	; (1670 <VectorEC+0x50>)
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    1630:	f8df 8040 	ldr.w	r8, [pc, #64]	; 1674 <VectorEC+0x54>
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    1634:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  for (pin = 0; pin < port_width; pin++) {
    1638:	2400      	movs	r4, #0
    if (isfr & (1 << pin)) {
    163a:	2501      	movs	r5, #1
    163c:	e002      	b.n	1644 <VectorEC+0x24>
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    163e:	3401      	adds	r4, #1
    1640:	2c08      	cmp	r4, #8
    1642:	d00e      	beq.n	1662 <VectorEC+0x42>
    if (isfr & (1 << pin)) {
    1644:	fa05 f304 	lsl.w	r3, r5, r4
    1648:	4233      	tst	r3, r6
    164a:	d0f8      	beq.n	163e <VectorEC+0x1e>
      expchannel_t channel = channel_map[pin];
    164c:	5de1      	ldrb	r1, [r4, r7]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    164e:	f8d8 3004 	ldr.w	r3, [r8, #4]
    1652:	4808      	ldr	r0, [pc, #32]	; (1674 <VectorEC+0x54>)
    1654:	eb03 1301 	add.w	r3, r3, r1, lsl #4
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    1658:	3401      	adds	r4, #1
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    165a:	685b      	ldr	r3, [r3, #4]
    165c:	4798      	blx	r3
  uint32_t isfr = port->ISFR;

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    165e:	2c08      	cmp	r4, #8
    1660:	d1f0      	bne.n	1644 <VectorEC+0x24>
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTD, KINETIS_EXT_PORTD_WIDTH, portd_channel_map);

  OSAL_IRQ_EPILOGUE();
}
    1662:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTD_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTD, KINETIS_EXT_PORTD_WIDTH, portd_channel_map);

  OSAL_IRQ_EPILOGUE();
    1666:	f7ff bc4b 	b.w	f00 <_port_irq_epilogue>
    166a:	bf00      	nop
    166c:	4004c000 	.word	0x4004c000
    1670:	1fffe804 	.word	0x1fffe804
    1674:	1fffe7f8 	.word	0x1fffe7f8
    1678:	f3af 8000 	nop.w
    167c:	f3af 8000 	nop.w

00001680 <VectorF0>:
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    1680:	4b12      	ldr	r3, [pc, #72]	; (16cc <VectorF0+0x4c>)
 * @brief   PORTE interrupt handler.
 *
 * @isr
 */
#if defined(KINETIS_PORTE_IRQ_VECTOR) && KINETIS_EXT_PORTE_WIDTH > 0
OSAL_IRQ_HANDLER(KINETIS_PORTE_IRQ_VECTOR) {
    1682:	b510      	push	{r4, lr}
/*
 * Generic interrupt handler.
 */
static inline void irq_handler(PORT_TypeDef * const port, const unsigned port_width, const uint8_t *channel_map) {
  unsigned pin;
  uint32_t isfr = port->ISFR;
    1684:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;
    1688:	f04f 32ff 	mov.w	r2, #4294967295
    168c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
    1690:	07e2      	lsls	r2, r4, #31
    1692:	d405      	bmi.n	16a0 <VectorF0+0x20>
    1694:	07a3      	lsls	r3, r4, #30
    1696:	d40d      	bmi.n	16b4 <VectorF0+0x34>
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTE, KINETIS_EXT_PORTE_WIDTH, porte_channel_map);

  OSAL_IRQ_EPILOGUE();
}
    1698:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTE_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTE, KINETIS_EXT_PORTE_WIDTH, porte_channel_map);

  OSAL_IRQ_EPILOGUE();
    169c:	f7ff bc30 	b.w	f00 <_port_irq_epilogue>
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    16a0:	4b0b      	ldr	r3, [pc, #44]	; (16d0 <VectorF0+0x50>)
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    16a2:	480c      	ldr	r0, [pc, #48]	; (16d4 <VectorF0+0x54>)
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    16a4:	7819      	ldrb	r1, [r3, #0]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    16a6:	6843      	ldr	r3, [r0, #4]
    16a8:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    16ac:	685b      	ldr	r3, [r3, #4]
    16ae:	4798      	blx	r3

  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
    16b0:	07a3      	lsls	r3, r4, #30
    16b2:	d5f1      	bpl.n	1698 <VectorF0+0x18>
      expchannel_t channel = channel_map[pin];
    16b4:	4b06      	ldr	r3, [pc, #24]	; (16d0 <VectorF0+0x50>)
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    16b6:	4807      	ldr	r0, [pc, #28]	; (16d4 <VectorF0+0x54>)
  /* Clear all pending interrupts on this port. */
  port->ISFR = 0xFFFFFFFF;

  for (pin = 0; pin < port_width; pin++) {
    if (isfr & (1 << pin)) {
      expchannel_t channel = channel_map[pin];
    16b8:	7859      	ldrb	r1, [r3, #1]
      EXTD1.config->channels[channel].cb(&EXTD1, channel);
    16ba:	6843      	ldr	r3, [r0, #4]
    16bc:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    16c0:	685b      	ldr	r3, [r3, #4]
    16c2:	4798      	blx	r3
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTE, KINETIS_EXT_PORTE_WIDTH, porte_channel_map);

  OSAL_IRQ_EPILOGUE();
}
    16c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
OSAL_IRQ_HANDLER(KINETIS_PORTE_IRQ_VECTOR) {
  OSAL_IRQ_PROLOGUE();

  irq_handler(PORTE, KINETIS_EXT_PORTE_WIDTH, porte_channel_map);

  OSAL_IRQ_EPILOGUE();
    16c8:	f7ff bc1a 	b.w	f00 <_port_irq_epilogue>
    16cc:	4004d000 	.word	0x4004d000
    16d0:	1fffe800 	.word	0x1fffe800
    16d4:	1fffe7f8 	.word	0x1fffe7f8
    16d8:	f3af 8000 	nop.w
    16dc:	f3af 8000 	nop.w

000016e0 <ext_lld_init>:
 * @notapi
 */
void ext_lld_init(void) {

  /* Driver initialization.*/
  extObjectInit(&EXTD1);
    16e0:	4801      	ldr	r0, [pc, #4]	; (16e8 <ext_lld_init+0x8>)
    16e2:	f7ff bc5d 	b.w	fa0 <extObjectInit>
    16e6:	bf00      	nop
    16e8:	1fffe7f8 	.word	0x1fffe7f8
    16ec:	f3af 8000 	nop.w

000016f0 <ext_lld_channel_enable>:
 * @notapi
 */
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {

  uint32_t irqc;
  uint32_t mode = extp->config->channels[channel].mode;
    16f0:	6842      	ldr	r2, [r0, #4]
    16f2:	0109      	lsls	r1, r1, #4
    16f4:	5853      	ldr	r3, [r2, r1]
  if (mode & EXT_CH_MODE_RISING_EDGE)
    16f6:	07d8      	lsls	r0, r3, #31
    16f8:	d415      	bmi.n	1726 <ext_lld_channel_enable+0x36>
    irqc = PCR_IRQC_RISING_EDGE;
  else if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
    16fa:	0798      	lsls	r0, r3, #30
    16fc:	d410      	bmi.n	1720 <ext_lld_channel_enable+0x30>
    irqc = PCR_IRQC_FALLING_EDGE;
  else if (extp->config->channels[channel].mode & EXT_CH_MODE_BOTH_EDGES)
    16fe:	f013 0303 	ands.w	r3, r3, #3
    1702:	bf18      	it	ne
    1704:	f44f 2330 	movne.w	r3, #720896	; 0xb0000
    irqc = PCR_IRQC_EITHER_EDGE;
  else
    irqc = PCR_IRQC_DISABLED;

  PORT_TypeDef *port = extp->config->channels[channel].port;
    1708:	3108      	adds	r1, #8
    170a:	1850      	adds	r0, r2, r1
    170c:	5851      	ldr	r1, [r2, r1]
    170e:	6840      	ldr	r0, [r0, #4]
  uint32_t pin = extp->config->channels[channel].pin;

  uint32_t pcr = port->PCR[pin];
    1710:	f851 2020 	ldr.w	r2, [r1, r0, lsl #2]

  /* Clear all the IRQC bits */
  pcr &= ~PORTx_PCRn_IRQC_MASK;
    1714:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
  /* Set the required IRQC bits */
  pcr |= PORTx_PCRn_IRQC(irqc);
    1718:	4313      	orrs	r3, r2

  port->PCR[pin] = pcr;
    171a:	f841 3020 	str.w	r3, [r1, r0, lsl #2]
    171e:	4770      	bx	lr
    1720:	f44f 2320 	mov.w	r3, #655360	; 0xa0000
    1724:	e7f0      	b.n	1708 <ext_lld_channel_enable+0x18>
    1726:	f44f 2310 	mov.w	r3, #589824	; 0x90000
    172a:	e7ed      	b.n	1708 <ext_lld_channel_enable+0x18>
    172c:	f3af 8000 	nop.w

00001730 <ext_lld_start>:
 *
 * @param[in] extp      pointer to the @p EXTDriver object
 *
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
    1730:	b538      	push	{r3, r4, r5, lr}
  expchannel_t channel;

  if (extp->state == EXT_STOP)
    1732:	6803      	ldr	r3, [r0, #0]
    1734:	2b01      	cmp	r3, #1
 *
 * @param[in] extp      pointer to the @p EXTDriver object
 *
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
    1736:	4605      	mov	r5, r0
  expchannel_t channel;

  if (extp->state == EXT_STOP)
    1738:	d03e      	beq.n	17b8 <ext_lld_start+0x88>
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (channel = 0; channel < EXT_MAX_CHANNELS; channel++) {

    uint32_t mode = extp->config->channels[channel].mode;
    173a:	686a      	ldr	r2, [r5, #4]
    PORT_TypeDef *port = extp->config->channels[channel].port;
    uint32_t pin = extp->config->channels[channel].pin;

    /* Initialize the channel map */
#if KINETIS_EXT_PORTA_WIDTH > 0
    if (port == PORTA)
    173c:	4929      	ldr	r1, [pc, #164]	; (17e4 <ext_lld_start+0xb4>)

  /* Configuration of automatic channels.*/
  for (channel = 0; channel < EXT_MAX_CHANNELS; channel++) {

    uint32_t mode = extp->config->channels[channel].mode;
    PORT_TypeDef *port = extp->config->channels[channel].port;
    173e:	6893      	ldr	r3, [r2, #8]
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (channel = 0; channel < EXT_MAX_CHANNELS; channel++) {

    uint32_t mode = extp->config->channels[channel].mode;
    1740:	6814      	ldr	r4, [r2, #0]
    PORT_TypeDef *port = extp->config->channels[channel].port;
    uint32_t pin = extp->config->channels[channel].pin;
    1742:	68d2      	ldr	r2, [r2, #12]

    /* Initialize the channel map */
#if KINETIS_EXT_PORTA_WIDTH > 0
    if (port == PORTA)
    1744:	428b      	cmp	r3, r1
    1746:	d01a      	beq.n	177e <ext_lld_start+0x4e>
      porta_channel_map[pin] = channel;
    else
#endif
#if KINETIS_EXT_PORTB_WIDTH > 0
    if (port == PORTB)
    1748:	4927      	ldr	r1, [pc, #156]	; (17e8 <ext_lld_start+0xb8>)
    174a:	428b      	cmp	r3, r1
    174c:	d024      	beq.n	1798 <ext_lld_start+0x68>
      portb_channel_map[pin] = channel;
    else
#endif
#if KINETIS_EXT_PORTC_WIDTH > 0
    if (port == PORTC)
    174e:	4927      	ldr	r1, [pc, #156]	; (17ec <ext_lld_start+0xbc>)
    1750:	428b      	cmp	r3, r1
    1752:	d025      	beq.n	17a0 <ext_lld_start+0x70>
      portc_channel_map[pin] = channel;
    else
#endif
#if KINETIS_EXT_PORTD_WIDTH > 0
    if (port == PORTD)
    1754:	4926      	ldr	r1, [pc, #152]	; (17f0 <ext_lld_start+0xc0>)
    1756:	428b      	cmp	r3, r1
    1758:	d026      	beq.n	17a8 <ext_lld_start+0x78>
      portd_channel_map[pin] = channel;
    else
#endif
#if KINETIS_EXT_PORTE_WIDTH > 0
    if (port == PORTE)
    175a:	4926      	ldr	r1, [pc, #152]	; (17f4 <ext_lld_start+0xc4>)
    175c:	428b      	cmp	r3, r1
    175e:	d027      	beq.n	17b0 <ext_lld_start+0x80>
      porte_channel_map[pin] = channel;
    else
#endif
    {}

    if (mode & EXT_CH_MODE_AUTOSTART)
    1760:	0761      	lsls	r1, r4, #29
    1762:	d406      	bmi.n	1772 <ext_lld_start+0x42>
      ext_lld_channel_enable(extp, channel);
    else if (port != NULL)
    1764:	2b00      	cmp	r3, #0
    1766:	d03c      	beq.n	17e2 <ext_lld_start+0xb2>
 */
void ext_lld_channel_disable(EXTDriver *extp, expchannel_t channel) {

  PORT_TypeDef *port = extp->config->channels[channel].port;
  uint32_t pin = extp->config->channels[channel].pin;
  port->PCR[pin] |= PORTx_PCRn_IRQC(PCR_IRQC_DISABLED);
    1768:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    176c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    1770:	bd38      	pop	{r3, r4, r5, pc}
    else
#endif
    {}

    if (mode & EXT_CH_MODE_AUTOSTART)
      ext_lld_channel_enable(extp, channel);
    1772:	4628      	mov	r0, r5
    1774:	2100      	movs	r1, #0
    else if (port != NULL)
      ext_lld_channel_disable(extp, channel);
  }
}
    1776:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    else
#endif
    {}

    if (mode & EXT_CH_MODE_AUTOSTART)
      ext_lld_channel_enable(extp, channel);
    177a:	f7ff bfb9 	b.w	16f0 <ext_lld_channel_enable>
    uint32_t pin = extp->config->channels[channel].pin;

    /* Initialize the channel map */
#if KINETIS_EXT_PORTA_WIDTH > 0
    if (port == PORTA)
      porta_channel_map[pin] = channel;
    177e:	4b1e      	ldr	r3, [pc, #120]	; (17f8 <ext_lld_start+0xc8>)
    1780:	2100      	movs	r1, #0
    1782:	5499      	strb	r1, [r3, r2]
      porte_channel_map[pin] = channel;
    else
#endif
    {}

    if (mode & EXT_CH_MODE_AUTOSTART)
    1784:	0763      	lsls	r3, r4, #29
    1786:	d4f4      	bmi.n	1772 <ext_lld_start+0x42>
    1788:	686a      	ldr	r2, [r5, #4]
    178a:	6893      	ldr	r3, [r2, #8]
    178c:	68d2      	ldr	r2, [r2, #12]
 */
void ext_lld_channel_disable(EXTDriver *extp, expchannel_t channel) {

  PORT_TypeDef *port = extp->config->channels[channel].port;
  uint32_t pin = extp->config->channels[channel].pin;
  port->PCR[pin] |= PORTx_PCRn_IRQC(PCR_IRQC_DISABLED);
    178e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    1792:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    1796:	bd38      	pop	{r3, r4, r5, pc}
      porta_channel_map[pin] = channel;
    else
#endif
#if KINETIS_EXT_PORTB_WIDTH > 0
    if (port == PORTB)
      portb_channel_map[pin] = channel;
    1798:	4b18      	ldr	r3, [pc, #96]	; (17fc <ext_lld_start+0xcc>)
    179a:	2100      	movs	r1, #0
    179c:	5499      	strb	r1, [r3, r2]
    179e:	e7f1      	b.n	1784 <ext_lld_start+0x54>
    else
#endif
#if KINETIS_EXT_PORTC_WIDTH > 0
    if (port == PORTC)
      portc_channel_map[pin] = channel;
    17a0:	4b17      	ldr	r3, [pc, #92]	; (1800 <ext_lld_start+0xd0>)
    17a2:	2100      	movs	r1, #0
    17a4:	5499      	strb	r1, [r3, r2]
    17a6:	e7ed      	b.n	1784 <ext_lld_start+0x54>
    else
#endif
#if KINETIS_EXT_PORTD_WIDTH > 0
    if (port == PORTD)
      portd_channel_map[pin] = channel;
    17a8:	4b16      	ldr	r3, [pc, #88]	; (1804 <ext_lld_start+0xd4>)
    17aa:	2100      	movs	r1, #0
    17ac:	5499      	strb	r1, [r3, r2]
    17ae:	e7e9      	b.n	1784 <ext_lld_start+0x54>
    else
#endif
#if KINETIS_EXT_PORTE_WIDTH > 0
    if (port == PORTE)
      porte_channel_map[pin] = channel;
    17b0:	4b15      	ldr	r3, [pc, #84]	; (1808 <ext_lld_start+0xd8>)
    17b2:	2100      	movs	r1, #0
    17b4:	5499      	strb	r1, [r3, r2]
    17b6:	e7e5      	b.n	1784 <ext_lld_start+0x54>
 * @notapi
 */
static void ext_lld_exti_irq_enable(void) {

#if KINETIS_EXT_PORTA_WIDTH > 0
  nvicEnableVector(PINA_IRQn, KINETIS_EXT_PORTA_IRQ_PRIORITY);
    17b8:	2028      	movs	r0, #40	; 0x28
    17ba:	2103      	movs	r1, #3
    17bc:	f7ff fc80 	bl	10c0 <nvicEnableVector>
#endif
#if KINETIS_EXT_PORTB_WIDTH > 0
  nvicEnableVector(PINB_IRQn, KINETIS_EXT_PORTB_IRQ_PRIORITY);
    17c0:	2029      	movs	r0, #41	; 0x29
    17c2:	2103      	movs	r1, #3
    17c4:	f7ff fc7c 	bl	10c0 <nvicEnableVector>
#endif
#if KINETIS_EXT_PORTC_WIDTH > 0
  nvicEnableVector(PINC_IRQn, KINETIS_EXT_PORTC_IRQ_PRIORITY);
    17c8:	202a      	movs	r0, #42	; 0x2a
    17ca:	2103      	movs	r1, #3
    17cc:	f7ff fc78 	bl	10c0 <nvicEnableVector>
#endif
#if KINETIS_EXT_PORTD_WIDTH > 0
  nvicEnableVector(PIND_IRQn, KINETIS_EXT_PORTD_IRQ_PRIORITY);
    17d0:	202b      	movs	r0, #43	; 0x2b
    17d2:	2103      	movs	r1, #3
    17d4:	f7ff fc74 	bl	10c0 <nvicEnableVector>
#endif
#if KINETIS_EXT_PORTE_WIDTH > 0
  nvicEnableVector(PINE_IRQn, KINETIS_EXT_PORTE_IRQ_PRIORITY);
    17d8:	202c      	movs	r0, #44	; 0x2c
    17da:	2103      	movs	r1, #3
    17dc:	f7ff fc70 	bl	10c0 <nvicEnableVector>
    17e0:	e7ab      	b.n	173a <ext_lld_start+0xa>
    17e2:	bd38      	pop	{r3, r4, r5, pc}
    17e4:	40049000 	.word	0x40049000
    17e8:	4004a000 	.word	0x4004a000
    17ec:	4004b000 	.word	0x4004b000
    17f0:	4004c000 	.word	0x4004c000
    17f4:	4004d000 	.word	0x4004d000
    17f8:	1fffe82c 	.word	0x1fffe82c
    17fc:	1fffe818 	.word	0x1fffe818
    1800:	1fffe80c 	.word	0x1fffe80c
    1804:	1fffe804 	.word	0x1fffe804
    1808:	1fffe800 	.word	0x1fffe800
    180c:	f3af 8000 	nop.w

00001810 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
    1810:	b508      	push	{r3, lr}
    1812:	2320      	movs	r3, #32
    1814:	f383 8811 	msr	BASEPRI, r3
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
    1818:	f7fe ff22 	bl	660 <chSysTimerHandlerI>
    181c:	2300      	movs	r3, #0
    181e:	f383 8811 	msr	BASEPRI, r3
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
    1822:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
    1826:	f7ff bb6b 	b.w	f00 <_port_irq_epilogue>
    182a:	bf00      	nop
    182c:	f3af 8000 	nop.w

00001830 <st_lld_init>:
 */
void st_lld_init(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (KINETIS_SYSCLK_FREQUENCY / OSAL_ST_FREQUENCY) - 1;
    1830:	4b05      	ldr	r3, [pc, #20]	; (1848 <st_lld_init+0x18>)
    1832:	f64b 307f 	movw	r0, #47999	; 0xbb7f
  SysTick->VAL = 0;
    1836:	2100      	movs	r1, #0
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
    1838:	2207      	movs	r2, #7
 */
void st_lld_init(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (KINETIS_SYSCLK_FREQUENCY / OSAL_ST_FREQUENCY) - 1;
    183a:	6058      	str	r0, [r3, #4]
  SysTick->VAL = 0;
    183c:	6099      	str	r1, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, KINETIS_ST_IRQ_PRIORITY);
    183e:	200b      	movs	r0, #11
    1840:	2108      	movs	r1, #8
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (KINETIS_SYSCLK_FREQUENCY / OSAL_ST_FREQUENCY) - 1;
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
    1842:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, KINETIS_ST_IRQ_PRIORITY);
    1844:	f7ff bc5c 	b.w	1100 <nvicSetSystemHandlerPriority>
    1848:	e000e010 	.word	0xe000e010
    184c:	f3af 8000 	nop.w

00001850 <__early_init>:
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {

  mk20d50_clock_init();
    1850:	f7ff bc66 	b.w	1120 <mk20d50_clock_init>
    1854:	f3af 8000 	nop.w
    1858:	f3af 8000 	nop.w
    185c:	f3af 8000 	nop.w

00001860 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
    1860:	4770      	bx	lr
    1862:	bf00      	nop
    1864:	f3af 8000 	nop.w
    1868:	f3af 8000 	nop.w
    186c:	f3af 8000 	nop.w

00001870 <extcb1>:
/* Triggered when done goes low, white LED stops flashing */
static void extcb1(EXTDriver *extp, expchannel_t channel) {
  (void)extp;
  (void)channel;

  done_state = 1;
    1870:	4b01      	ldr	r3, [pc, #4]	; (1878 <extcb1+0x8>)
    1872:	2201      	movs	r2, #1
    1874:	701a      	strb	r2, [r3, #0]
    1876:	4770      	bx	lr
    1878:	1fffe840 	.word	0x1fffe840
    187c:	f3af 8000 	nop.w

00001880 <main>:
};

/*
 * Application entry point.
 */
int main(void) {
    1880:	b580      	push	{r7, lr}
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
    1882:	f7ff fb65 	bl	f50 <halInit>
  chSysInit();

  orchardShellInit();

  chprintf(stream, "\r\n\r\nNeTVCR bootloader.  Based on build %s\r\n", gitversion);
    1886:	4d1f      	ldr	r5, [pc, #124]	; (1904 <main+0x84>)
  chprintf(stream, "Core free memory : %d bytes\r\n", chCoreGetStatusX());

  // IOPORT1 = PORTA, IOPORT2 = PORTB, etc...
  palClearPad(IOPORT1, 4);    // white LED, active low
  palSetPad(IOPORT3, 3);    // MCU_F_MODE, set to 1, specifies JTAG mode. Clear to 0 for SPI.
    1888:	4f1f      	ldr	r7, [pc, #124]	; (1908 <main+0x88>)

  chprintf(stream, "\r\n\r\nNeTVCR bootloader.  Based on build %s\r\n", gitversion);
  chprintf(stream, "Core free memory : %d bytes\r\n", chCoreGetStatusX());

  // IOPORT1 = PORTA, IOPORT2 = PORTB, etc...
  palClearPad(IOPORT1, 4);    // white LED, active low
    188a:	4e20      	ldr	r6, [pc, #128]	; (190c <main+0x8c>)
    188c:	4c20      	ldr	r4, [pc, #128]	; (1910 <main+0x90>)
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
  chSysInit();
    188e:	f7fe fe97 	bl	5c0 <chSysInit>

  orchardShellInit();
    1892:	f000 f875 	bl	1980 <orchardShellInit>

  chprintf(stream, "\r\n\r\nNeTVCR bootloader.  Based on build %s\r\n", gitversion);
    1896:	4b1f      	ldr	r3, [pc, #124]	; (1914 <main+0x94>)
    1898:	491f      	ldr	r1, [pc, #124]	; (1918 <main+0x98>)
    189a:	681a      	ldr	r2, [r3, #0]
    189c:	6828      	ldr	r0, [r5, #0]
    189e:	f000 fa37 	bl	1d10 <chprintf>
  chprintf(stream, "Core free memory : %d bytes\r\n", chCoreGetStatusX());
    18a2:	682d      	ldr	r5, [r5, #0]
    18a4:	f7ff fafc 	bl	ea0 <chCoreGetStatusX>
    18a8:	491c      	ldr	r1, [pc, #112]	; (191c <main+0x9c>)
    18aa:	4602      	mov	r2, r0
    18ac:	4628      	mov	r0, r5
    18ae:	f000 fa2f 	bl	1d10 <chprintf>

  // IOPORT1 = PORTA, IOPORT2 = PORTB, etc...
  palClearPad(IOPORT1, 4);    // white LED, active low
  palSetPad(IOPORT3, 3);    // MCU_F_MODE, set to 1, specifies JTAG mode. Clear to 0 for SPI.
  palSetPad(IOPORT2, 0);    // FPGA_DRIVE, normally enable FPGA to drive the SPI bus
    18b2:	4b1b      	ldr	r3, [pc, #108]	; (1920 <main+0xa0>)
  chprintf(stream, "\r\n\r\nNeTVCR bootloader.  Based on build %s\r\n", gitversion);
  chprintf(stream, "Core free memory : %d bytes\r\n", chCoreGetStatusX());

  // IOPORT1 = PORTA, IOPORT2 = PORTB, etc...
  palClearPad(IOPORT1, 4);    // white LED, active low
  palSetPad(IOPORT3, 3);    // MCU_F_MODE, set to 1, specifies JTAG mode. Clear to 0 for SPI.
    18b4:	2208      	movs	r2, #8
  palSetPad(IOPORT2, 0);    // FPGA_DRIVE, normally enable FPGA to drive the SPI bus
  //  palSetPad(IOPORT2, 1);    // MCU_F_INIT initiall an input, don't stall configuration
  palSetPad(IOPORT3, 1);    // MCU_F_PROG, set PROG high, pulse low to reset the FPGA
    18b6:	f04f 0802 	mov.w	r8, #2
  chprintf(stream, "Core free memory : %d bytes\r\n", chCoreGetStatusX());

  // IOPORT1 = PORTA, IOPORT2 = PORTB, etc...
  palClearPad(IOPORT1, 4);    // white LED, active low
  palSetPad(IOPORT3, 3);    // MCU_F_MODE, set to 1, specifies JTAG mode. Clear to 0 for SPI.
  palSetPad(IOPORT2, 0);    // FPGA_DRIVE, normally enable FPGA to drive the SPI bus
    18ba:	f04f 0901 	mov.w	r9, #1

  chprintf(stream, "\r\n\r\nNeTVCR bootloader.  Based on build %s\r\n", gitversion);
  chprintf(stream, "Core free memory : %d bytes\r\n", chCoreGetStatusX());

  // IOPORT1 = PORTA, IOPORT2 = PORTB, etc...
  palClearPad(IOPORT1, 4);    // white LED, active low
    18be:	2510      	movs	r5, #16
    18c0:	60b5      	str	r5, [r6, #8]
  //  palSetPad(IOPORT2, 1);    // MCU_F_INIT initiall an input, don't stall configuration
  palSetPad(IOPORT3, 1);    // MCU_F_PROG, set PROG high, pulse low to reset the FPGA


  // pulse PROG now that the Mode pin has been setup
  chThdSleepMilliseconds(1);
    18c2:	4648      	mov	r0, r9
  chprintf(stream, "\r\n\r\nNeTVCR bootloader.  Based on build %s\r\n", gitversion);
  chprintf(stream, "Core free memory : %d bytes\r\n", chCoreGetStatusX());

  // IOPORT1 = PORTA, IOPORT2 = PORTB, etc...
  palClearPad(IOPORT1, 4);    // white LED, active low
  palSetPad(IOPORT3, 3);    // MCU_F_MODE, set to 1, specifies JTAG mode. Clear to 0 for SPI.
    18c4:	607a      	str	r2, [r7, #4]
  palSetPad(IOPORT2, 0);    // FPGA_DRIVE, normally enable FPGA to drive the SPI bus
    18c6:	f8c3 9004 	str.w	r9, [r3, #4]
  //  palSetPad(IOPORT2, 1);    // MCU_F_INIT initiall an input, don't stall configuration
  palSetPad(IOPORT3, 1);    // MCU_F_PROG, set PROG high, pulse low to reset the FPGA
    18ca:	f8c7 8004 	str.w	r8, [r7, #4]


  // pulse PROG now that the Mode pin has been setup
  chThdSleepMilliseconds(1);
    18ce:	f7ff f8d7 	bl	a80 <chThdSleep>
  palClearPad(IOPORT3, 1);    // MCU_F_PROG, set PROG high, pulse low to reset the FPGA (min width = 250ns)
  chThdSleepMilliseconds(1);
    18d2:	4648      	mov	r0, r9
  palSetPad(IOPORT3, 1);    // MCU_F_PROG, set PROG high, pulse low to reset the FPGA


  // pulse PROG now that the Mode pin has been setup
  chThdSleepMilliseconds(1);
  palClearPad(IOPORT3, 1);    // MCU_F_PROG, set PROG high, pulse low to reset the FPGA (min width = 250ns)
    18d4:	f8c7 8008 	str.w	r8, [r7, #8]
  chThdSleepMilliseconds(1);
    18d8:	f7ff f8d2 	bl	a80 <chThdSleep>
  palSetPad(IOPORT3, 1);
  
  /*
   * Activates the EXT driver 1.
   */
  palSetPadMode(IOPORT3, 2, PAL_MODE_INPUT_PULLUP);  // FPGA done
    18dc:	4638      	mov	r0, r7
    18de:	4641      	mov	r1, r8

  // pulse PROG now that the Mode pin has been setup
  chThdSleepMilliseconds(1);
  palClearPad(IOPORT3, 1);    // MCU_F_PROG, set PROG high, pulse low to reset the FPGA (min width = 250ns)
  chThdSleepMilliseconds(1);
  palSetPad(IOPORT3, 1);
    18e0:	f8c7 8004 	str.w	r8, [r7, #4]
  
  /*
   * Activates the EXT driver 1.
   */
  palSetPadMode(IOPORT3, 2, PAL_MODE_INPUT_PULLUP);  // FPGA done
    18e4:	2203      	movs	r2, #3
    18e6:	f7ff fc9b 	bl	1220 <_pal_lld_setpadmode>
  extStart(&EXTD1, &extcfg);
    18ea:	480e      	ldr	r0, [pc, #56]	; (1924 <main+0xa4>)
    18ec:	490e      	ldr	r1, [pc, #56]	; (1928 <main+0xa8>)
    18ee:	f7ff fb5f 	bl	fb0 <extStart>
  
  //  usbd_connect(__FALSE);
#endif
  
  while (1) {
    chThdSleepMilliseconds(500);
    18f2:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    18f6:	f7ff f8c3 	bl	a80 <chThdSleep>
    if( done_state )
    18fa:	7823      	ldrb	r3, [r4, #0]
    18fc:	2b00      	cmp	r3, #0
    18fe:	d0f8      	beq.n	18f2 <main+0x72>
      palTogglePad(IOPORT1, 4);
    1900:	60f5      	str	r5, [r6, #12]
    1902:	e7f6      	b.n	18f2 <main+0x72>
    1904:	1fffe848 	.word	0x1fffe848
    1908:	400ff080 	.word	0x400ff080
    190c:	400ff000 	.word	0x400ff000
    1910:	1fffe840 	.word	0x1fffe840
    1914:	1fffe600 	.word	0x1fffe600
    1918:	000020f0 	.word	0x000020f0
    191c:	0000211c 	.word	0x0000211c
    1920:	400ff040 	.word	0x400ff040
    1924:	1fffe7f8 	.word	0x1fffe7f8
    1928:	000020e0 	.word	0x000020e0
    192c:	f3af 8000 	nop.w

00001930 <HardFault_Handler>:
register void *stack_pointer asm("sp");

void HardFault_Handler(void) {
/*lint -restore*/
  // Hijack the process stack pointer to make backtrace work
  asm("mrs %0, psp" : "=r"(HARDFAULT_PSP) : :);
    1930:	4b03      	ldr	r3, [pc, #12]	; (1940 <HardFault_Handler+0x10>)
  stack_pointer = HARDFAULT_PSP;
    1932:	f3ef 8209 	mrs	r2, PSP
    1936:	4695      	mov	sp, r2
register void *stack_pointer asm("sp");

void HardFault_Handler(void) {
/*lint -restore*/
  // Hijack the process stack pointer to make backtrace work
  asm("mrs %0, psp" : "=r"(HARDFAULT_PSP) : :);
    1938:	601a      	str	r2, [r3, #0]
  stack_pointer = HARDFAULT_PSP;

  /* Break into the debugger */
  asm("bkpt #0");
    193a:	be00      	bkpt	0x0000

  while(1);
    193c:	e7fe      	b.n	193c <HardFault_Handler+0xc>
    193e:	bf00      	nop
    1940:	1fffe844 	.word	0x1fffe844
    1944:	f3af 8000 	nop.w
    1948:	f3af 8000 	nop.w
    194c:	f3af 8000 	nop.w

00001950 <MemManage_Handler>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void MemManage_Handler(void) {
/*lint -restore*/

  while (true) {
  }
    1950:	e7fe      	b.n	1950 <MemManage_Handler>
    1952:	bf00      	nop
    1954:	f3af 8000 	nop.w
    1958:	f3af 8000 	nop.w
    195c:	f3af 8000 	nop.w

00001960 <BusFault_Handler>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void BusFault_Handler(void) {
/*lint -restore*/

  while (true) {
  }
    1960:	e7fe      	b.n	1960 <BusFault_Handler>
    1962:	bf00      	nop
    1964:	f3af 8000 	nop.w
    1968:	f3af 8000 	nop.w
    196c:	f3af 8000 	nop.w

00001970 <UsageFault_Handler>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void UsageFault_Handler(void) {
/*lint -restore*/

  while (true) {
  }
    1970:	e7fe      	b.n	1970 <UsageFault_Handler>
    1972:	bf00      	nop
    1974:	f3af 8000 	nop.w
    1978:	f3af 8000 	nop.w
    197c:	f3af 8000 	nop.w

00001980 <orchardShellInit>:
//static THD_WORKING_AREA(waShellThread, 288);
static THD_WORKING_AREA(waShellThread, 288);
//static THD_WORKING_AREA(waShellThread, 560); // to accommodate gfx

void orchardShellInit(void)
{
    1980:	b510      	push	{r4, lr}
  sdStart(serialDriver, &serialConfig);
    1982:	4c05      	ldr	r4, [pc, #20]	; (1998 <orchardShellInit+0x18>)
    1984:	4905      	ldr	r1, [pc, #20]	; (199c <orchardShellInit+0x1c>)
    1986:	4620      	mov	r0, r4
    1988:	f7ff fb8a 	bl	10a0 <sdStart>
  stream = stream_driver;
    198c:	4b04      	ldr	r3, [pc, #16]	; (19a0 <orchardShellInit+0x20>)
    198e:	601c      	str	r4, [r3, #0]

  shellInit();
}
    1990:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void orchardShellInit(void)
{
  sdStart(serialDriver, &serialConfig);
  stream = stream_driver;

  shellInit();
    1994:	f000 b9cc 	b.w	1d30 <shellInit>
    1998:	1fffe780 	.word	0x1fffe780
    199c:	00002140 	.word	0x00002140
    19a0:	1fffe848 	.word	0x1fffe848
    19a4:	f3af 8000 	nop.w
    19a8:	f3af 8000 	nop.w
    19ac:	f3af 8000 	nop.w

000019b0 <long_to_string_with_divisor.constprop.0>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
    19b0:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
    19b2:	f100 070b 	add.w	r7, r0, #11
    19b6:	463c      	mov	r4, r7
    19b8:	460d      	mov	r5, r1
  do {
    i = (int)(l % radix);
    19ba:	fbb1 f6f2 	udiv	r6, r1, r2
    19be:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
    19c2:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9')
    19c6:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
    19c8:	bfc8      	it	gt
    19ca:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    *--q = i;
    19ce:	b2db      	uxtb	r3, r3
    19d0:	f804 3d01 	strb.w	r3, [r4, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
    19d4:	fbb5 f5f2 	udiv	r5, r5, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
    19d8:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
    19da:	2d00      	cmp	r5, #0
    19dc:	d1ed      	bne.n	19ba <long_to_string_with_divisor.constprop.0+0xa>

  i = (int)(p + MAX_FILLER - q);
    19de:	1b3a      	subs	r2, r7, r4
    19e0:	4402      	add	r2, r0
    19e2:	e001      	b.n	19e8 <long_to_string_with_divisor.constprop.0+0x38>
    19e4:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  do
    *p++ = *q++;
    19e8:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
    19ec:	4290      	cmp	r0, r2
    19ee:	d1f9      	bne.n	19e4 <long_to_string_with_divisor.constprop.0+0x34>

  return p;
}
    19f0:	bcf0      	pop	{r4, r5, r6, r7}
    19f2:	4770      	bx	lr
    19f4:	f3af 8000 	nop.w
    19f8:	f3af 8000 	nop.w
    19fc:	f3af 8000 	nop.w

00001a00 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
    1a00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1a04:	b087      	sub	sp, #28
    1a06:	4615      	mov	r5, r2
    1a08:	f10d 030d 	add.w	r3, sp, #13
    1a0c:	aa03      	add	r2, sp, #12
    1a0e:	1a9b      	subs	r3, r3, r2
    1a10:	4681      	mov	r9, r0
    1a12:	468a      	mov	sl, r1
    1a14:	9301      	str	r3, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
    1a16:	f04f 0800 	mov.w	r8, #0
    1a1a:	468b      	mov	fp, r1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
    1a1c:	f89b 1000 	ldrb.w	r1, [fp]
    1a20:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
    1a24:	b179      	cbz	r1, 1a46 <chvprintf+0x46>
      return n;
    if (c != '%') {
    1a26:	2925      	cmp	r1, #37	; 0x25
    1a28:	d011      	beq.n	1a4e <chvprintf+0x4e>
      streamPut(chp, (uint8_t)c);
    1a2a:	f8d9 2000 	ldr.w	r2, [r9]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
    1a2e:	469b      	mov	fp, r3
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
    1a30:	6892      	ldr	r2, [r2, #8]
    1a32:	4648      	mov	r0, r9
    1a34:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
    1a36:	f89b 1000 	ldrb.w	r1, [fp]
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
    1a3a:	f108 0801 	add.w	r8, r8, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
    1a3e:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
    1a42:	2900      	cmp	r1, #0
    1a44:	d1ef      	bne.n	1a26 <chvprintf+0x26>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
    1a46:	4640      	mov	r0, r8
    1a48:	b007      	add	sp, #28
    1a4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
    1a4e:	f89b 2001 	ldrb.w	r2, [fp, #1]
    1a52:	2a2d      	cmp	r2, #45	; 0x2d
    1a54:	bf03      	ittte	eq
    1a56:	f89b 2002 	ldrbeq.w	r2, [fp, #2]
      fmt++;
    1a5a:	f10b 0302 	addeq.w	r3, fp, #2
      left_align = TRUE;
    1a5e:	f04f 0a01 	moveq.w	sl, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    1a62:	f04f 0a00 	movne.w	sl, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
    1a66:	2a30      	cmp	r2, #48	; 0x30
    1a68:	bf03      	ittte	eq
    1a6a:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
    1a6c:	3301      	addeq	r3, #1
      filler = '0';
    1a6e:	2730      	moveq	r7, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    1a70:	2720      	movne	r7, #32
    1a72:	1c59      	adds	r1, r3, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
    1a74:	2600      	movs	r6, #0
    1a76:	e006      	b.n	1a86 <chvprintf+0x86>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
    1a78:	782b      	ldrb	r3, [r5, #0]
    1a7a:	3504      	adds	r5, #4
    1a7c:	f89b 2000 	ldrb.w	r2, [fp]
      else
        break;
      width = width * 10 + c;
    1a80:	eb03 0640 	add.w	r6, r3, r0, lsl #1
    1a84:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
    1a86:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
    1a8a:	b2db      	uxtb	r3, r3
    1a8c:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
    1a8e:	468b      	mov	fp, r1
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
    1a90:	eb06 0086 	add.w	r0, r6, r6, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
    1a94:	d9f2      	bls.n	1a7c <chvprintf+0x7c>
        c -= '0';
      else if (c == '*')
    1a96:	2a2a      	cmp	r2, #42	; 0x2a
    1a98:	d0ee      	beq.n	1a78 <chvprintf+0x78>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
    1a9a:	2a2e      	cmp	r2, #46	; 0x2e
    1a9c:	f04f 0100 	mov.w	r1, #0
    1aa0:	d043      	beq.n	1b2a <chvprintf+0x12a>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
    1aa2:	f002 03df 	and.w	r3, r2, #223	; 0xdf
    1aa6:	2b4c      	cmp	r3, #76	; 0x4c
    1aa8:	d04e      	beq.n	1b48 <chvprintf+0x148>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    1aaa:	f1a2 0044 	sub.w	r0, r2, #68	; 0x44
    1aae:	2834      	cmp	r0, #52	; 0x34
    1ab0:	f200 80f7 	bhi.w	1ca2 <chvprintf+0x2a2>
    1ab4:	e8df f010 	tbh	[pc, r0, lsl #1]
    1ab8:	00f500ea 	.word	0x00f500ea
    1abc:	00f500f5 	.word	0x00f500f5
    1ac0:	00ea00f5 	.word	0x00ea00f5
    1ac4:	00f500f5 	.word	0x00f500f5
    1ac8:	00f500f5 	.word	0x00f500f5
    1acc:	00e800f5 	.word	0x00e800f5
    1ad0:	00f500f5 	.word	0x00f500f5
    1ad4:	00f500f5 	.word	0x00f500f5
    1ad8:	00dd00f5 	.word	0x00dd00f5
    1adc:	00f500f5 	.word	0x00f500f5
    1ae0:	00f500f2 	.word	0x00f500f2
    1ae4:	00f500f5 	.word	0x00f500f5
    1ae8:	00f500f5 	.word	0x00f500f5
    1aec:	00f500f5 	.word	0x00f500f5
    1af0:	00f500f5 	.word	0x00f500f5
    1af4:	00a100f5 	.word	0x00a100f5
    1af8:	00f500ea 	.word	0x00f500ea
    1afc:	00f500f5 	.word	0x00f500f5
    1b00:	00ea00f5 	.word	0x00ea00f5
    1b04:	00f500f5 	.word	0x00f500f5
    1b08:	00f500f5 	.word	0x00f500f5
    1b0c:	00e800f5 	.word	0x00e800f5
    1b10:	00f500f5 	.word	0x00f500f5
    1b14:	007100f5 	.word	0x007100f5
    1b18:	00dd00f5 	.word	0x00dd00f5
    1b1c:	00f500f5 	.word	0x00f500f5
    1b20:	00f2      	.short	0x00f2
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
    1b22:	782b      	ldrb	r3, [r5, #0]
    1b24:	3504      	adds	r5, #4
        else
          break;
        precision *= 10;
        precision += c;
    1b26:	eb03 0140 	add.w	r1, r3, r0, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
    1b2a:	f81b 2b01 	ldrb.w	r2, [fp], #1
        if (c >= '0' && c <= '9')
    1b2e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
    1b32:	b2db      	uxtb	r3, r3
    1b34:	2b09      	cmp	r3, #9
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
    1b36:	eb01 0081 	add.w	r0, r1, r1, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
    1b3a:	d9f4      	bls.n	1b26 <chvprintf+0x126>
          c -= '0';
        else if (c == '*')
    1b3c:	2a2a      	cmp	r2, #42	; 0x2a
    1b3e:	d0f0      	beq.n	1b22 <chvprintf+0x122>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
    1b40:	f002 03df 	and.w	r3, r2, #223	; 0xdf
    1b44:	2b4c      	cmp	r3, #76	; 0x4c
    1b46:	d1b0      	bne.n	1aaa <chvprintf+0xaa>
      is_long = TRUE;
      if (*fmt)
    1b48:	f89b 3000 	ldrb.w	r3, [fp]
    1b4c:	2b00      	cmp	r3, #0
    1b4e:	f000 80a8 	beq.w	1ca2 <chvprintf+0x2a2>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    1b52:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
    1b56:	f10b 0b01 	add.w	fp, fp, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    1b5a:	2a34      	cmp	r2, #52	; 0x34
    1b5c:	f200 80a0 	bhi.w	1ca0 <chvprintf+0x2a0>
    1b60:	e8df f002 	tbb	[pc, r2]
    1b64:	9e9e9e94 	.word	0x9e9e9e94
    1b68:	9e9e949e 	.word	0x9e9e949e
    1b6c:	929e9e9e 	.word	0x929e9e9e
    1b70:	9e9e9e9e 	.word	0x9e9e9e9e
    1b74:	9e9e879e 	.word	0x9e9e879e
    1b78:	9e9e9e9c 	.word	0x9e9e9e9c
    1b7c:	9e9e9e9e 	.word	0x9e9e9e9e
    1b80:	4b9e9e9e 	.word	0x4b9e9e9e
    1b84:	9e9e9e94 	.word	0x9e9e9e94
    1b88:	9e9e949e 	.word	0x9e9e949e
    1b8c:	929e9e9e 	.word	0x929e9e9e
    1b90:	1b9e9e9e 	.word	0x1b9e9e9e
    1b94:	9e9e879e 	.word	0x9e9e879e
    1b98:	9c          	.byte	0x9c
    1b99:	00          	.byte	0x00
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
    1b9a:	682c      	ldr	r4, [r5, #0]
        s = "(null)";
    1b9c:	4b5a      	ldr	r3, [pc, #360]	; (1d08 <chvprintf+0x308>)
    1b9e:	2c00      	cmp	r4, #0
    1ba0:	bf08      	it	eq
    1ba2:	461c      	moveq	r4, r3
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
    1ba4:	3504      	adds	r5, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    1ba6:	7823      	ldrb	r3, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
    1ba8:	2900      	cmp	r1, #0
    1baa:	f000 8094 	beq.w	1cd6 <chvprintf+0x2d6>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    1bae:	2b00      	cmp	r3, #0
    1bb0:	f000 8096 	beq.w	1ce0 <chvprintf+0x2e0>
    1bb4:	3901      	subs	r1, #1
    1bb6:	4620      	mov	r0, r4
    1bb8:	e001      	b.n	1bbe <chvprintf+0x1be>
    1bba:	3901      	subs	r1, #1
    1bbc:	d403      	bmi.n	1bc6 <chvprintf+0x1c6>
    1bbe:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    1bc2:	2b00      	cmp	r3, #0
    1bc4:	d1f9      	bne.n	1bba <chvprintf+0x1ba>
    1bc6:	1b00      	subs	r0, r0, r4
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
    1bc8:	1a36      	subs	r6, r6, r0
    1bca:	1e43      	subs	r3, r0, #1
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
    1bcc:	2720      	movs	r7, #32
    1bce:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
    1bd2:	f1ba 0f00 	cmp.w	sl, #0
    1bd6:	d01f      	beq.n	1c18 <chvprintf+0x218>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
    1bd8:	2b00      	cmp	r3, #0
    1bda:	9300      	str	r3, [sp, #0]
    1bdc:	da34      	bge.n	1c48 <chvprintf+0x248>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
    1bde:	2e00      	cmp	r6, #0
    1be0:	f43f af1c 	beq.w	1a1c <chvprintf+0x1c>
    1be4:	4634      	mov	r4, r6
      streamPut(chp, (uint8_t)filler);
    1be6:	f8d9 3000 	ldr.w	r3, [r9]
    1bea:	4648      	mov	r0, r9
    1bec:	689b      	ldr	r3, [r3, #8]
    1bee:	4639      	mov	r1, r7
    1bf0:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
    1bf2:	3c01      	subs	r4, #1
    1bf4:	d1f7      	bne.n	1be6 <chvprintf+0x1e6>
    1bf6:	44b0      	add	r8, r6
    1bf8:	e710      	b.n	1a1c <chvprintf+0x1c>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
    1bfa:	682b      	ldr	r3, [r5, #0]
    1bfc:	f88d 300c 	strb.w	r3, [sp, #12]
    1c00:	9b01      	ldr	r3, [sp, #4]
    1c02:	3504      	adds	r5, #4
    1c04:	4618      	mov	r0, r3
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
    1c06:	2720      	movs	r7, #32
    1c08:	3b01      	subs	r3, #1
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    1c0a:	ac03      	add	r4, sp, #12
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
    1c0c:	1a36      	subs	r6, r6, r0
    1c0e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      width = 0;
    if (left_align == FALSE)
    1c12:	f1ba 0f00 	cmp.w	sl, #0
    1c16:	d1df      	bne.n	1bd8 <chvprintf+0x1d8>
    1c18:	9300      	str	r3, [sp, #0]
      width = -width;
    1c1a:	f1c6 0a00 	rsb	sl, r6, #0
    if (width < 0) {
    1c1e:	f1ba 0f00 	cmp.w	sl, #0
    1c22:	d045      	beq.n	1cb0 <chvprintf+0x2b0>
      if (*s == '-' && filler == '0') {
    1c24:	7821      	ldrb	r1, [r4, #0]
    1c26:	292d      	cmp	r1, #45	; 0x2d
    1c28:	d047      	beq.n	1cba <chvprintf+0x2ba>
        streamPut(chp, (uint8_t)*s++);
        n++;
    1c2a:	4656      	mov	r6, sl
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
    1c2c:	f8d9 3000 	ldr.w	r3, [r9]
    1c30:	4648      	mov	r0, r9
    1c32:	689b      	ldr	r3, [r3, #8]
    1c34:	4639      	mov	r1, r7
    1c36:	4798      	blx	r3
        n++;
      } while (++width != 0);
    1c38:	3601      	adds	r6, #1
    1c3a:	d1f7      	bne.n	1c2c <chvprintf+0x22c>
    }
    while (--i >= 0) {
    1c3c:	9b00      	ldr	r3, [sp, #0]
    1c3e:	2b00      	cmp	r3, #0
    1c40:	ebca 0808 	rsb	r8, sl, r8
    1c44:	f6ff aeea 	blt.w	1a1c <chvprintf+0x1c>
    1c48:	f8dd a000 	ldr.w	sl, [sp]
      streamPut(chp, (uint8_t)*s++);
    1c4c:	f8d9 3000 	ldr.w	r3, [r9]
    1c50:	f814 1b01 	ldrb.w	r1, [r4], #1
    1c54:	689b      	ldr	r3, [r3, #8]
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
    1c56:	f10a 3aff 	add.w	sl, sl, #4294967295
      streamPut(chp, (uint8_t)*s++);
    1c5a:	4648      	mov	r0, r9
    1c5c:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
    1c5e:	f1ba 3fff 	cmp.w	sl, #4294967295
    1c62:	d1f3      	bne.n	1c4c <chvprintf+0x24c>
    1c64:	9b00      	ldr	r3, [sp, #0]
    1c66:	f108 0801 	add.w	r8, r8, #1
    1c6a:	2b00      	cmp	r3, #0
    1c6c:	bfa8      	it	ge
    1c6e:	4498      	addge	r8, r3
    1c70:	e7b5      	b.n	1bde <chvprintf+0x1de>
      c = 16;
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
      goto unsigned_common;
    1c72:	220a      	movs	r2, #10
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
    1c74:	6829      	ldr	r1, [r5, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
    1c76:	a803      	add	r0, sp, #12
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
    1c78:	3504      	adds	r5, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
    1c7a:	f7ff fe99 	bl	19b0 <long_to_string_with_divisor.constprop.0>
    1c7e:	ab03      	add	r3, sp, #12
    1c80:	1ac0      	subs	r0, r0, r3
    1c82:	1e43      	subs	r3, r0, #1
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    1c84:	ac03      	add	r4, sp, #12
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    1c86:	e7c1      	b.n	1c0c <chvprintf+0x20c>
    1c88:	2208      	movs	r2, #8
    1c8a:	e7f3      	b.n	1c74 <chvprintf+0x274>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
    1c8c:	6829      	ldr	r1, [r5, #0]
      if (l < 0) {
    1c8e:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
    1c90:	f105 0504 	add.w	r5, r5, #4
      if (l < 0) {
    1c94:	db2e      	blt.n	1cf4 <chvprintf+0x2f4>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    1c96:	a803      	add	r0, sp, #12
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
    1c98:	220a      	movs	r2, #10
    1c9a:	e7ee      	b.n	1c7a <chvprintf+0x27a>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    1c9c:	2210      	movs	r2, #16
    1c9e:	e7e9      	b.n	1c74 <chvprintf+0x274>
    1ca0:	461a      	mov	r2, r3
    1ca2:	9b01      	ldr	r3, [sp, #4]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
    1ca4:	f88d 200c 	strb.w	r2, [sp, #12]
    1ca8:	4618      	mov	r0, r3
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    1caa:	ac03      	add	r4, sp, #12
    1cac:	3b01      	subs	r3, #1
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
      break;
    1cae:	e7ad      	b.n	1c0c <chvprintf+0x20c>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
    1cb0:	9b00      	ldr	r3, [sp, #0]
    1cb2:	2b00      	cmp	r3, #0
    1cb4:	4656      	mov	r6, sl
    1cb6:	dac7      	bge.n	1c48 <chvprintf+0x248>
    1cb8:	e6b0      	b.n	1a1c <chvprintf+0x1c>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
    1cba:	2f30      	cmp	r7, #48	; 0x30
    1cbc:	d1b5      	bne.n	1c2a <chvprintf+0x22a>
        streamPut(chp, (uint8_t)*s++);
    1cbe:	f8d9 3000 	ldr.w	r3, [r9]
    1cc2:	4648      	mov	r0, r9
    1cc4:	689b      	ldr	r3, [r3, #8]
    1cc6:	4798      	blx	r3
    1cc8:	9b00      	ldr	r3, [sp, #0]
    1cca:	3b01      	subs	r3, #1
    1ccc:	3401      	adds	r4, #1
        n++;
    1cce:	f108 0801 	add.w	r8, r8, #1
    1cd2:	9300      	str	r3, [sp, #0]
    1cd4:	e7a9      	b.n	1c2a <chvprintf+0x22a>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
    1cd6:	f647 71fe 	movw	r1, #32766	; 0x7ffe
    1cda:	2b00      	cmp	r3, #0
    1cdc:	f47f af6b 	bne.w	1bb6 <chvprintf+0x1b6>
    1ce0:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
    1ce4:	f1ba 0f00 	cmp.w	sl, #0
    1ce8:	d10b      	bne.n	1d02 <chvprintf+0x302>
    1cea:	f04f 33ff 	mov.w	r3, #4294967295
    1cee:	9300      	str	r3, [sp, #0]
    1cf0:	2720      	movs	r7, #32
    1cf2:	e792      	b.n	1c1a <chvprintf+0x21a>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
    1cf4:	232d      	movs	r3, #45	; 0x2d
        l = -l;
    1cf6:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
    1cf8:	f88d 300c 	strb.w	r3, [sp, #12]
    1cfc:	f10d 000d 	add.w	r0, sp, #13
    1d00:	e7ca      	b.n	1c98 <chvprintf+0x298>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
    1d02:	2720      	movs	r7, #32
    1d04:	e76b      	b.n	1bde <chvprintf+0x1de>
    1d06:	bf00      	nop
    1d08:	00002180 	.word	0x00002180
    1d0c:	f3af 8000 	nop.w

00001d10 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
    1d10:	b40e      	push	{r1, r2, r3}
    1d12:	b500      	push	{lr}
    1d14:	b082      	sub	sp, #8
    1d16:	aa03      	add	r2, sp, #12
    1d18:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
    1d1c:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
    1d1e:	f7ff fe6f 	bl	1a00 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
    1d22:	b002      	add	sp, #8
    1d24:	f85d eb04 	ldr.w	lr, [sp], #4
    1d28:	b003      	add	sp, #12
    1d2a:	4770      	bx	lr
    1d2c:	f3af 8000 	nop.w

00001d30 <shellInit>:
    1d30:	4b01      	ldr	r3, [pc, #4]	; (1d38 <shellInit+0x8>)
    1d32:	601b      	str	r3, [r3, #0]
    1d34:	4770      	bx	lr
    1d36:	bf00      	nop
    1d38:	1fffe84c 	.word	0x1fffe84c
    1d3c:	f3af 8000 	nop.w
    1d40:	00000020 	.word	0x00000020
    1d44:	00000040 	.word	0x00000040
    1d48:	00000080 	.word	0x00000080
    1d4c:	00000100 	.word	0x00000100
    1d50:	00000200 	.word	0x00000200
    1d54:	00000400 	.word	0x00000400
    1d58:	00000500 	.word	0x00000500
    1d5c:	00000600 	.word	0x00000600

00001d60 <ram_areas>:
    1d60:	0000218c 1fffe850 1fffe850 1fffe850     .!..P...P...P...
    1d70:	0000218c 00000000 00000000 00000000     .!..............
    1d80:	0000218c 00000000 00000000 00000000     .!..............
    1d90:	0000218c 00000000 00000000 00000000     .!..............
    1da0:	0000218c 00000000 00000000 00000000     .!..............
    1db0:	0000218c 00000000 00000000 00000000     .!..............
    1dc0:	0000218c 00000000 00000000 00000000     .!..............
    1dd0:	0000218c 00000000 00000000 00000000     .!..............
    1de0:	656c6469 00000000 00000000 00000000     idle............

00001df0 <ch_debug>:
    1df0:	6e69616d 18431600 08440404 1814100c     main..C...D.....
    1e00:	1e1d1c00 0000001f 00000000 00000000     ................

00001e10 <vmt>:
    1e10:	00001001 00000fe1 00001041 00001021     ........A...!...
    1e20:	00001031 00001011 00000ff1 00000fd1     1...............

00001e30 <default_config>:
    1e30:	00009600 00000000 00000000 00000000     ................

00001e40 <pal_default_config>:
    1e40:	400ff000 00000010 0000000b 0000000b     ...@............
    1e50:	00000010 00000006 00000001 00000001     ................
    1e60:	00000001 00000001 00000001 00000001     ................
    1e70:	00000001 00000001 00000001 00000001     ................
    1e80:	00000001 00000001 00000001 00000005     ................
    1e90:	00000005 00000001 00000001 00000001     ................
    1ea0:	00000001 00000001 00000001 00000001     ................
    1eb0:	00000001 00000001 00000001 00000001     ................
    1ec0:	00000001 400ff040 00000006 00000002     ....@..@........
    1ed0:	00000001 00000001 00000001 00000001     ................
    1ee0:	00000001 00000001 00000001 00000001     ................
    1ef0:	00000001 00000001 00000001 00000001     ................
    1f00:	00000001 00000001 00000001 00000001     ................
    1f10:	00000001 00000001 00000001 00000001     ................
    1f20:	00000001 00000001 00000001 00000001     ................
    1f30:	00000001 00000001 00000001 00000001     ................
    1f40:	00000001 00000001 400ff080 00000001     ...........@....
    1f50:	00000006 00000002 00000006 00000002     ................
    1f60:	00000002 00000002 00000002 00000001     ................
    1f70:	00000001 00000001 00000001 00000001     ................
    1f80:	00000001 00000001 00000001 00000001     ................
    1f90:	00000001 00000001 00000001 00000001     ................
    1fa0:	00000001 00000001 00000001 00000001     ................
    1fb0:	00000001 00000001 00000001 00000001     ................
    1fc0:	00000001 00000001 00000001 400ff0c0     ...............@
    1fd0:	00000001 00000001 00000001 00000001     ................
    1fe0:	00000001 00000001 00000001 00000001     ................
    1ff0:	00000001 00000001 00000001 00000001     ................
    2000:	00000001 00000001 00000001 00000001     ................
    2010:	00000001 00000001 00000001 00000001     ................
    2020:	00000001 00000001 00000001 00000001     ................
    2030:	00000001 00000001 00000001 00000001     ................
    2040:	00000001 00000001 00000001 00000001     ................
    2050:	400ff100 00000001 00000001 00000001     ...@............
    2060:	00000001 00000001 00000001 00000001     ................
    2070:	00000001 00000001 00000001 00000001     ................
    2080:	00000001 00000001 00000001 00000001     ................
    2090:	00000001 00000001 00000001 00000001     ................
    20a0:	00000001 00000001 00000001 00000001     ................
    20b0:	00000001 00000001 00000001 00000001     ................
    20c0:	00000001 00000001 00000001 00000001     ................
    20d0:	00000001 00000000 00000000 00000000     ................

000020e0 <extcfg>:
    20e0:	00000006 00001871 40049000 00000001     ....q......@....
    20f0:	0a0d0a0d 5654654e 62205243 6c746f6f     ....NeTVCR bootl
    2100:	6564616f 20202e72 65736142 6e6f2064     oader.  Based on
    2110:	69756220 2520646c 000a0d73 65726f43      build %s...Core
    2120:	65726620 656d2065 79726f6d 25203a20      free memory : %
    2130:	79622064 0d736574 0000000a 00000000     d bytes.........

00002140 <serialConfig>:
    2140:	0001c200 00000000 00000000 00000000     ................
    2150:	36366535 66656362 62303832 31633236     5e66bcef280b62c1
    2160:	39303230 38323334 62353838 31383136     02094328885b6181
    2170:	37366262 37636533 00000000 00000000     bb673ec7........
    2180:	6c756e28 0000296c                       (null)..
